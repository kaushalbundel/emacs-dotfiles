<p>Rust has a lot of nice things that make life easy.
One of the least discussed ones is also one of my favorites.
It's a little nugget in the standard library that makes handling possible failures a lot easier.
And it's not even baked inâ€”it just falls out from the type system.</p>
<h1 id="nicely-handling-multiple-results-or-options">Nicely handling multiple <code>Result</code>s or <code>Option</code>s</h1>
<p>When you do something that can fail, you get back a type that reflects that.
You'll get either a <code>Result&lt;T, E&gt;</code> or an <code>Option&lt;T&gt;</code>, depending on if it's something that could fail or could just not be present.
When you work in Rust, you end up getting <em>very</em> comfortable with these types, and there are a lot of ergonomics to help you.</p>
<p>One of those bits of ergonomics that I love is how you can collect an iterable of <code>Results</code> into a <code>Result</code> of a <code>Vec</code>, effectively flipping the result inside out: you would expect a <code>Vec&lt;Result&lt;T, E&gt;&gt;</code>, and you can get a <code>Result&lt;Vec&lt;T&gt;, E&gt;</code> instead!
The same thing applies for <code>Option</code>.
Let's see it in action.</p>
<p>Suppose you have a function which could fail, and you call it a number of times.
Something like this:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn fetch_chunk(from: usize, to: usize) -&gt; Result&lt;Row, Error&gt; {
    &#x2F;&#x2F; some implementation
}
</code></pre>
<p>When we call it, and if we collect directly, we get a bunch of <code>Result</code>s:</p>
<pre><code>let chunks: Vec&lt;Result&lt;Row, Error&gt;&gt; =
    indexes.iter().map(|i| fetch_chunk(i, i+1)).collect();
</code></pre>
<p>Now this is kind of ugly to deal with.
In a lot of cases, it <em>is</em> the type you want, because you can see which operations failed<sup class="footnote-reference">
  <a href="#fn-1" id="fn-ref-1">1</a>
</sup>
.
But sometimes, you just want to know if <em>anything</em> failed, and in that case you can collect directly into a <code>Result</code>.</p>
<pre><code>let chunks: Result&lt;Vec&lt;Row&gt;, Error&gt; =
    indexes.iter().map(|i| fetch_chunk(i, i+1)).collect();
</code></pre>
<p>This is the same code with a different type signature, and it collects into a <em>different type</em>.
That's pretty darn cool, if you ask me.
Just by which type you ask for, you get that one back!</p>
<p>This pattern of pulling the Result from the inside to the outside is one that's present in functional programming languages.
I was trying to find a name for it, and the closest parallel we<sup class="footnote-reference">
  <a href="#fn-2" id="fn-ref-2">2</a>
</sup>
 found was Haskell's <a href="https://hackage.haskell.org/package/base-4.19.0.0/docs/Control-Monad.html#v:sequence"><code>sequence</code></a>, which is somewhat unsatisfying in the end since it feels like there should be a name for the <em>concept</em> of this pulling the result type from the inside to the outside.</p>
<p>You can do other nice things in a similar way here.</p>
<h1 id="how-it-works">How it works</h1>
<p>Under the hood, there's no magic here.
This isn't built into Rust.
It's just part of the standard library, and you can implement things like that for your own types!</p>
<p><code>collect</code> is the method where the magic happens.
It's a very general method on <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html">iterators</a>, with this type from <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.collect">the docs</a>:</p>
<pre><code>fn collect&lt;B&gt;(self) -&gt; B
where
    B: FromIterator&lt;Self::Item&gt;,
    Self: Sized,
</code></pre>
<p>This is basically saying that for any type that implements <code>FromIterator</code> for the type that this iterator yields, you can collect it into that type.
An easy example is how an iterator with <code>Item = i32</code> can be used to collect into a <code>Vec&lt;i32&gt;</code>, since <code>Vec</code> implements <code>FromIterator</code> for all types.</p>
<p>And then the magic is these two impls:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/result/enum.Result.html#impl-FromIterator%3CResult%3CA,+E%3E%3E-for-Result%3CV,+E%3E"><code>FromIterator&lt;Result&lt;A, E&gt;&gt; for Result&lt;V, E&gt; where V: FromIterator&lt;A&gt;</code></a></li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#impl-FromIterator%3COption%3CA%3E%3E-for-Option%3CV%3E"><code>FromIterator&lt;Option&lt;A&gt;&gt; for Option&lt;V&gt; where V: FromIterator&lt;A&gt;</code></a></li>
</ul>
<p>We know that that type <code>V</code> can be our Vec or whatever, so these implementations provide what we need to get the whole magical <code>collect</code> behavior to fall out.
The types are <em>scary</em>, though, especially if you're not very familiar with strongly typed FP languages.</p>
<h1 id="how-do-you-find-this-out">How do you find this out?</h1>
<p>Things like this are hard to discover on your own in Rust.
That's one of my laments with the language.</p>
<p>How I discovered it: initally, I think I saw it in the book or when pairing with other people.
Later on, I also saw it in the <code>collect</code> docs, which gave some very useful examples of how to use it for this use case.
It's also explained in <a href="https://doc.rust-lang.org/rust-by-example/error/iter_result.html">Rust By Example</a><sup class="footnote-reference">
  <a href="#fn-3" id="fn-ref-3">3</a>
</sup>
, along with a few other examples.</p>
<p>The type system here does get in the way of good discoverability, in my opinion, since it's not super clear what combinations of traits on which types will give you what you need.
I don't know how to improve it, other than talking gleefully about things that are fun like this and spreading the word.</p>
<p>What other cool Rust things should the world know about?</p>
