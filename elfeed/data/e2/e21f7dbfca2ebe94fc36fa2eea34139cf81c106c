<p>There's a common quote in the software world that you should &quot;make it work, make it right, then make it fast.&quot;<sup class="footnote-reference"><a href="#1">1</a></sup>
This is a catchy aphorism, and it is often taken as a rule.
But in its short form, it misses some crucial nuance.
Let's unpack it to see what's missing, then how to do things right.</p>
<h1 id="what-does-it-mean">What does it mean?</h1>
<p>Unpacking the statement, we have three distinct phases.</p>
<p>First, we <em>make it work</em>.
In this step, you get something working.
It should handle a basic case of the problem you're solving, but doesn't need to handle edge cases.
Sometimes you might skip tests, sometimes you might make a mess.
But you show that it <em>can</em> be done and figure out roughly what it will take.</p>
<p>Then, we <em>make it right</em>.
This step is where you tighten up all the loose ends from the first step.
Handle all the edge cases, test the code, clean up any messes, do any refactoring.
The end result here is a working artifact that meets all the requirements.</p>
<p>And then, we <em>make it fast</em>.
This is the step I see skipped all the time, and it's where you go back and speed things up.
You do some profiling, see how things perform, then tweak and improve until you have satisfactory performance.</p>
<h1 id="the-problem">The problem</h1>
<p>Here's the problem:
You are in for a world of hurt if you leave &quot;make it fast&quot; for the last step.
And that's probably why we have so much slow software in the world.</p>
<p>After you've gone through the trouble of making software right, if you have major performance problems, they are likely to be fundamental to the approach you took.
You'll be able to speed things up somewhat, but major improvements will require more invasive and painful refactoring.
This is often simply not given enough time, and we hack things up to limp by.</p>
<p>The reality is that if you want to have a hope of making your software perform well, you have to think about performance from the beginning.
You wouldn't start making the software without thinking about what correctness is.
Nor should you start it without thinking about how to make it fast.</p>
<p>When you start making something, to make it work, you have to have a conception of what &quot;make it right&quot; will look like so that you can design with that in mind and not back yourself into a corner.
It's exactly the same with &quot;make it fast.&quot;</p>
<p>You have to make sure from the outset that your architecture supports the performance you need.
Otherwise you may wind up with decisions that are difficult to reverse but stand between you and performance, and then you have to practically rewrite the whole thing.
And it's not just the architecture level.
Every line of code you write impacts performance.
People want to profile a codebase and find <em>the</em> line of code that's making it slow, but usually it's endemic and spread throughout.
Small penalties spread throughout the whole project add up to a big total cost.</p>
<p>Instead, this is a crucial part of &quot;make it work.&quot;
In that first step where you handle the common cases and think about (but don't yet handle) the edge cases, you must do the same for performance.
Make sure that &quot;make it work&quot; includes an implicit &quot;fast enough when in realistic conditions.&quot;
Then as you layer on correctness, you can keep ensuring performance is sufficient.</p>
<p>But the aphorism <em>is</em> rather catchy...</p>
<h1 id="we-need-a-different-saying">We need a different saying</h1>
<p>Unfortunately, it's hard to capture nuance in an aphorism.
I think it's important to try, though:
This aphorism in particular is one I've heard used to justify some sloppy work which ended up painting projects into performance purgatory<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p>So what do we say instead?</p>
<p>I'm not sure.
Writing aphorisms isn't my forte!
The results from the LLMs I tried were also not great.
Suggestions are welcome, but I think the answer might be that we don't need an aphorism here.</p>
<p>Instead, we lean into the fact that we're doing engineering and we have to design all the requirements into the software, including performance.
We don't need an aphorism to justify our work.
We just have to remember that performance does matter (and is <em>part</em> of being correct for much software) and that it's a consideration throughout the entire process.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This is <a href="https://wiki.c2.com/?MakeItWorkMakeItRightMakeItFast">often attributed</a> to Kent Beck, but was published at least as early as 1983 by one Brian Kernighan.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>Pretty pleased with the alliteration.</p>
</div>
