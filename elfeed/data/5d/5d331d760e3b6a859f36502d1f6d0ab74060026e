<p>Recently I started working on a programming language, <a href="/blog/introducing-hurl/">Hurl</a>.
Writing the initial code samples and developing the concept is all fine and good, but the next step is to actually make it work.
The steps I outlined for developing Hurl in the last post were:</p>
<ol>
<li>Write out code samples to get a feel for Hurl and its semantics</li>
<li>Define Hurl's grammar in a loose BNF-esque fashion</li>
<li>Implement the lexer and parser</li>
<li>Write a formatter as a demoable use of the parser</li>
<li>Write an interpreter!</li>
</ol>
<p>The last post got us through number 1, getting code samples.
Huge thanks to the readers who pointed out typos and bugs in my programs, by the way!
Now it's time to move on to steps 2 and 3.</p>
<p>It's 2023, so naturally I decided to do as little of the work myself as possible.
The path I took was to first try to use ChatGPT to get me as far as I could, and then use my own human brain to finish the work.
My background is having taken just two PL courses in college and worked through <a href="https://craftinginterpreters.com/">Crafting Interpreters</a>.
I was curious to see how much an LLM could help me with something I have seen but am not an expert in.</p>
<p>Spoiler alert: I'd probably not use it again, but I think it helped?</p>
<h1 id="step-1-computer-write-me-a-grammar">Step 1: Computer, write me a grammar!</h1>
<p>To start things off, I turned to my trusty frenemy ChatGPT to see how much it could do for me.
Since I'm mostly developing this in my evenings after a full day of work and childcare, reducing friction is very helpful for making progress.
So I formed these three hypotheses going in:</p>
<ul>
<li>ChatGPT would generate a valid grammar for the language if I provided code examples and pointed out minor issues to iterate with it</li>
<li>ChatGPT would easily generate a standalone lexer for the language, again with some minor iteration required</li>
<li>ChatGPT would fail to generate a parser for the language</li>
</ul>
<p>I wanted to see how far I would get and test these hypotheses, then take the reins myself once ChatGPT couldn't get me further.
It was... a mixed bag.
I'll show you what I mean, but using ChatGPT got me started, but definitely didn't succeed at any of the steps independently<sup class="footnote-reference"><a href="#1">1</a></sup>.
And it failed <em>spectacularly</em> at writing the lexer, which I thought it would be great at.</p>
<p>I started off by feeding it my previous blog post as a source of proto-documentation on Hurl.
The first task was to break down the task of developing the language itself into discrete tickets.
It was pretty successful here!</p>
<p>The tickets it wrote were good, and the effort required from me was low, so it ended up definitely saving me time from writing out tickets myself.
(Yes, I use tickets for my personal projects. I need to project manage myself or I'll chase every squirrel and never accomplish a lick of real work.<sup class="footnote-reference"><a href="#3">2</a></sup>)
In particular, the breakdown for the grammar definition task was pretty helpful.
It reminded me that I need to include things like the comment syntax; while obvious in retrospect, I blanked on that need for a while.</p>
<p>After this, I told it to write the grammar in <a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF</a>.
I'm not worried about the details; this is just to help me/us develop the lexer and parser, so it doesn't need to be formal.
Foreshadowing, though: it would've helped to make it formal.</p>
<p>The grammar it generated was... close?
It seemed okay because I wasn't very familiar with writing grammars, but I ran into a number of issues down the road.
In particular, it couldn't really handle one request I had, which was to include comments in the grammar itself.
I wanted that because (1) I'm writing a formatter so the parse-tree needs to include comments to include them in the output, and (2) I'm the kind of monster who just <em>might</em> give the comments semantics someday.</p>
<p>For those things it couldn't handle itself, explaining the problem didn't help, it would enter an &quot;oops loop&quot;.
You know, where it just apologizes then repeats the <em>same exact mistake</em> again. And again. And again.
In those instances, I had to just <em>give it the answer</em>, exactly what I wanted in the grammar. Fine.</p>
<p>This is the grammar we ended up with:</p>
<pre><code>&lt;program&gt; ::= &lt;stmt_list&gt;
&lt;stmt_list&gt; ::= &lt;comment&gt; | &lt;stmt&gt; &lt;optional_comment&gt; &quot;;&quot; &lt;stmt_list&gt; | ε

&lt;stmt&gt; ::= &lt;declaration&gt;
         | &lt;func_definition&gt;
         | &lt;exception_handling&gt;
         | &lt;exception&gt;
         | &lt;expr&gt;

&lt;declaration&gt; ::= &quot;let&quot; &lt;identifier&gt; &quot;=&quot; &lt;expr&gt;

&lt;func_definition&gt; ::= &quot;func&quot; &quot;(&quot; &lt;params&gt; &quot;)&quot; &quot;{&quot; &lt;stmt_list&gt; &quot;}&quot;

&lt;params&gt; ::= &lt;identifier&gt; &quot;,&quot; &lt;params&gt; | &lt;identifier&gt; | ε

&lt;exception_handling&gt; ::= &quot;try&quot; &quot;{&quot; &lt;stmt_list&gt; &quot;}&quot; &lt;catch_list&gt;

&lt;catch_list&gt; ::= &lt;catch&gt; &lt;catch_list&gt; | &lt;catch&gt;

&lt;catch&gt; ::= &quot;catch&quot; &quot;as&quot; &lt;identifier&gt; &quot;{&quot; &lt;stmt_list&gt; &quot;}&quot;
          | &quot;catch&quot; &quot;(&quot; &lt;expr&gt; &quot;)&quot; &quot;{&quot; &lt;stmt_list&gt; &quot;}&quot;

&lt;exception&gt; ::= &quot;hurl&quot; &lt;expr&gt; | &quot;toss&quot; &lt;expr&gt;

&lt;expr&gt; ::= &lt;term&gt; &quot;+&quot; &lt;expr&gt; | &lt;term&gt; &quot;-&quot; &lt;expr&gt;
         | &lt;term&gt;

&lt;term&gt; ::= &lt;factor&gt; &quot;*&quot; &lt;term&gt; | &lt;factor&gt; &quot;&#x2F;&quot; &lt;term&gt; | &lt;factor&gt; &quot;%&quot; &lt;term&gt;
         | &lt;factor&gt;

&lt;factor&gt; ::= &quot;(&quot; &lt;expr&gt; &quot;)&quot;
           | &quot;~&quot; &lt;factor&gt;
           | &lt;identifier&gt;
           | &lt;number&gt;
           | &lt;string&gt;
           | &quot;true&quot;
           | &quot;false&quot;

&lt;identifier&gt; ::= &#x2F;[a-zA-Z_][a-zA-Z_0-9]*&#x2F;

&lt;number&gt; ::= &#x2F;[0-9]+(\.[0-9]+)?&#x2F;

&lt;string&gt; ::= &#x2F;&quot;([^&quot;\\]|\\.)*&quot;&#x2F;

&lt;comment&gt; ::= &quot;#&quot; &#x2F;[^\n]*&#x2F;

&lt;optional_comment&gt; ::= &lt;comment&gt; | ε
</code></pre>
<p>Those familiar with languages will probably notice a few issues with this.
Feel free to peruse it and tear it apart before moving on!</p>
<h1 id="step-2-computer-write-me-a-lexer-wait-no-another-grammar">Step 2: Computer, write me a lexer! Wait no, another grammar!</h1>
<p>The next thing I had it try was to write a lexer.
This just... failed.
I expected the structure to be at least okay and need revision, but what it came out with was to my eyes inscrutible.
This could be my own inexperience, but I decided that this wasn't going to work for us.</p>
<p>Instead, I changed tacks: let's use a parser-generator called <a href="https://pest.rs/">Pest</a>.
If it was able to generate one grammar for us, it can probably convert that to Pest's grammar and we get a parser out of it!</p>
<p>This part went okay.
Not great, just okay.</p>
<p>I gave it our grammar again and also an example of a Pest grammar, and had it convert our grammar to Pest's formal syntax.
This grammar ran into a few syntax errors when I tried to use it, which I fed back in, and it was able to correct successfully!</p>
<p>Then it was a matter of adding things to the grammar which had been omitted before, like member accesses and comparison operators.
This was where I <em>should have called things off</em>, but I stubbornly stuck with ChatGPT.
It got pretty unproductive, and instead of a little reading the docs, I kept trying to make ChatGPT do the thing for me.</p>
<p>Eventually we landed... somewhere. I don't have the full grammar here because ChatGPT kept digging us into holes and it just got tiresome.
This is where I hit eject and bailed out, switched to doing things myself.</p>
<h1 id="interlude-reading-pest-s-docs-a-rant">Interlude: Reading Pest's docs, a rant</h1>
<p>Part of the impetus here for using ChatGPT is that I was pretty intimidated by Pest (and other parser-generators).
I'd glanced at it and knew it was a powerful tool, but felt like it was some arcane magic that I couldn't learn easily on my own.
I wanted a crutch, a safety blanket, someone to tell me how to do it.</p>
<p>This was reinforced by the <a href="https://pest.rs/book/">Pest Book</a>, which is the official guide for learning to use Pest.
This is literally called a <strong>book</strong>.
So it's big, right? It's a lot to get through?
That notion scared me, kept me from reading the guide.
I bet it has scared other people off of it, too.</p>
<p>But... by my counts, the &quot;book&quot; is only in the order of 5,000 words for the meat of it about grammars.
This is substantial, but it's a far cry from the size of the Rust Book.
This is a <strong>long tutorial</strong>, not a book!</p>
<p>Can we <em>please</em> stop scaring people off of docs by calling them books?
It's not likely intended that way, and I won't speculate about reasons for calling it a book, but I think it's a bad thing to do.</p>
<p>Anyway, once I realized that the docs were not, in fact, a book, I read them.
Well, no, I'm a parent with limited time and energy: I <em>quickly skimmed them</em>.
And that was enough!</p>
<h1 id="step-3-revise-the-grammar-by-hand-and-write-a-parser">Step 3: Revise the grammar by hand, and write a parser</h1>
<p>From here, I revised the grammar by hand.
I'm sure it has bugs still, but now all my example programs successfully parse!</p>
<p>Getting everything to &quot;just&quot; parse was fairly straightforward, and then the more complicated bit (for me) was how to convert this into a concrete syntax tree.
(As opposed to an AST, a CST contains other things like comments! The more you know!)
Doing that conversion showed me things that were lacking in my grammar, like precedence of operators or whatnot.
The final grammar is <a href="https://git.sr.ht/~ntietz/hurl-lang/tree/main/item/hurl_grammar.pest">in the git repo</a> if you want to see it!
It's a little longer than the informal one, but reasonable.</p>
<p>During the conversion, I wrote the CST parser.
Pest gives you a parse tree as the result of parsing, which is fine but not super helpful for for writing tools like a formatter or interpreter.
Instead of being able to use CST structs, we just get general-purpose tree node types.
Converting these into a CST is fairly mechanical (and coding assistants such as Copilot <em>are</em> quite helpful for reducing this drudgery).</p>
<p>We walk the parse tree and for each node, parse it recursively.
Each time we're invoking a function like this:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">pub fn parse_assignment(pair: Pair&lt;Rule&gt;) -&gt; Result&lt;Stmt, ParseError&gt; {
    assert_eq!(pair.as_rule(), Rule::assignment);

    let mut inner = pair.into_inner();
    let ident = parse_ident(inner.next().unwrap())?;
    let expr = parse_expr(inner.next().unwrap())?;

    Ok(Stmt::Assignment(ident, expr))
}
</code></pre>
<p>We pass in a Pair (the parse tree node, basically) and get back either an error or a <code>Stmt</code> element of our CST.
Inside it, we first validate that we're at a valid point in the parse tree, then we parse the identifier and its expression and return those.
It's a pretty straightforward translation from the grammar.</p>
<p>The <a href="https://git.sr.ht/~ntietz/hurl-lang/tree/main/item/src/parser.rs">full parsing code</a> is also in the repo.</p>
<h1 id="next-steps">Next steps</h1>
<p>The rest of this project, I'm just going to use my brain and my usual cadre of coding tools (which includes Copilot for tedium-reduction).</p>
<p>My immediate next step is to write a formatter for Hurl!
The idea is that it will exercise the CST and parsing code and be a neat little demo, without the full effort of writing an interpreter.
And, of course, this very serious language demands very serious tools ;)</p>
<p>After that, it's time to write the interpreter itself.
The focus for it will just be to get <em>something</em> running.
I might do small benchmarks to make sure that it's &quot;reasonable&quot;, because I do want to be able to use this for coding challenges like Advent of Code.
But a language like Hurl is clearly not about performance (except in the sense of &quot;performance art&quot;).</p>
<h1 id="feelings-about-llms">Feelings about LLMs</h1>
<p>LLMs (and ChatGPT in particular) are an emotionally charged topic these days.
It's pretty natural for a technology like this that seems like it can be transformational.
I've run the gamut on them.
Last fall, I felt like they were overhyped and they were not useful; just get out of my way and stop distracting me!
This spring, I saw the demo for GPT-4 and drank it in deeply; it was an &quot;oh shit&quot; moment where I realized these are here to stay.
Ultimately I landed somewhere in the middle.</p>
<p>That GPT-4 demo launched me into a mode of exploring what we can do with LLMs and how I can use them for my work.
If LLMs are here to stay, I'd better figure out how to get value out of them.
My comfortable middle for now is:
LLMs are useful for my work sometimes, they're very powerful, and they have <strong>strong</strong> limits.</p>
<p>I probably won't use ChatGPT for another language project.
It helped me get through some portions of the project, with a lot of steering.
I had to lean on the meager PL knowledge I entered with, and wasted some time, but overall had a fun experience.
Next time I'll do it the old-fashioned human way, because I've learned about languages from this project.
But I might use ChatGPT or similar tools for other projects in other domains.</p>
<p>The future seems bright.
These tools have a lot of problems today (ethics around training and copyright loom large), but the potential for improving the world is great.
We need to face the problems head-on, and we also need to remember that this technology is <strong>worth pursuing ethically</strong>.
If we get it right, we can build a better world.</p>
<p>A world where this tired parent can write a programming language by herself in the evenings, after work and a trying bedtime with her toddler.</p>
<p>If that isn't worth pursuing, I don't know what is.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>The <a href="https://chat.openai.com/share/0279d864-d708-4789-b9ee-cf0982394058">full transcript</a> is available if you<sup class="footnote-reference"><a href="#2">3</a></sup> want to peruse it.</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">2</sup>
<p>Often distractions turn into footnotes, so... when I have footnotes on footnotes you know my focus was particularly poor that evening of writing!</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">3</sup>
<p>If you work at OpenAI or can put me in touch with a human who does, I'd love to talk about OpenAI's names policy. My deadname is on my account and it cannot be edited, which is a source of pain whenever I use ChatGPT. I'd like to provide feedback on this and kinda beg someone to help a girl out here.</p>
</div>
