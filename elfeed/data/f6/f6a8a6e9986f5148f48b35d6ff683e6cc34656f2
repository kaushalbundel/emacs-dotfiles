<p>I've been working on my programming language for a couple of months now, in fits and starts<sup class="footnote-reference"><a href="#1">1</a></sup>.
In the <a href="/blog/introducing-hurl/">original post</a>, I laid out my plan for it, and after creating the parser the next step was writing a formatter.
I thought this would be a nice intermediate step after writing the parser, something easy to exercise the code without being as complicated as the interpreter.</p>
<p>Well...
It was hard, even with the shortcuts I took.</p>
<p>The author of Crafting Interpreters once wrote that a formatter was the <a href="https://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/">hardest program he had written</a>, and now I can see why.
Mine is definitely not as sophisticated as his, and it was difficult to figure out on my own.</p>
<p>One of the big challenges I ran into was what interface to use for the formatter.
I wound up settling on this trait, along with a companion struct.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">&#x2F;&#x2F;&#x2F; Trait for types that can be formatted for pretty printing.
pub trait Format {
    fn fmt(&amp;self, ctx: &amp;mut FormatContext) -&gt; String;
}

pub struct FormatContext {
    pub indent: usize,
}

impl FormatContext {
    pub fn indent_incr(&amp;mut self) {
        self.indent += 4;
    }

    pub fn indent_decr(&amp;mut self) {
        self.indent -= 4;
    }
}
</code></pre>
<p>In an early iteration I was passing through a <code>Write</code> object directly, and writing into it as I went.
The issue with doing that was that I could only do one forward pass through the code, so if I ever wanted to limit line lengths, I couldn't!
When I wrote things, I would only know the local content and not what came before or after it.</p>
<p>So, instead I went for returning a <code>String</code> and building it iteratively.
This is perhaps not the most efficient choice, but optimization is for future-Nicole.
She loves that shit, so that's kind of a gift to my future self.</p>
<p>I also had to make sure to include some context inside each format call.
I originally passed in the indentation level directly, but quickly moved that into a mutable context variable.
Placing it inside a context struct allows me to more easily add more variables than if I have to add them to each implementation of the trait.
Right now the context only contains the indentation level, but could potentially contain more information, such as line lengths or format settings.</p>
<p>After that, it was a matter of just kind of chugging through and having it write out what each different piece of the tree corresponds to.
Here's an abridged version of what formatting a <code>Stmt</code> looks like.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">impl Format for Stmt {
    fn fmt(&amp;self, ctx: &amp;mut FmtCtx) -&gt; String {
        let tab = &quot; &quot;.repeat(ctx.indent);

        match self {
            Stmt::Import(expr) =&gt; {
                format!(&quot;{}include {};&quot;, &quot; &quot;.repeat(ctx.indent), expr.fmt(ctx))
            }
            Stmt::Declaration(ident, expr) =&gt; {
                let expr = expr.fmt(ctx);
                format!(&quot;{}let {} = {};&quot;, tab, ident.0, expr,)
            }
            &#x2F;&#x2F; ... SNIP! ...
        }
    }
}
</code></pre>
<p>One of the trickiest parts was handling blank lines.
My syntax tree did not include these originally, and my parser stripped out all whitespace.
What to do?
I tried two approaches.</p>
<p>First I tried integrating blank lines into the grammar and parsing it out, so that I could just directly print them.
This was a detour, and it was very messy and never worked right.
Ultimately, I had to abandon this path because there was no clean way to get it working.
The messy way would have involved updating every single part of my parser.
No <em>thank you</em>.</p>
<p>Then I stumbled into the more correct (less wrong?) way of doing it.
I used the line numbers provided while parsing!
If these line numbers differed by more than 1, I knew<sup class="footnote-reference"><a href="#2">2</a></sup> that there were extra blank lines between the two elements, so I emitted a <code>BlankLine</code> element in addition to whatever I was parsing.</p>
<p>This is a kludge in some ways, because there are edge cases (like the one in a footnote).
I think that the right way to do this is actually to include the line number information on the tokens themselves, and have more information than just the starting line number.
Where does a function start and end, for example?
But it works for now, and it allows me to potentially use the same tree for both the interpreter and the formatter.
This decision may not last forever, but it saves some time now.</p>
<p>There are a few things I skipped over for the sake of keeping the formatter simple.
The main one is line length.
Like the Go formatter, I just decided to let lines be as long as you want them to be, since that means I never need to deal with wrapping lines: one statement, one line.
I also didn't ever collapse blocks, they always span two lines.
And if you have a comment at the end of a line it gets shoved onto the next line.
Oh, and there's no semblance of proper error handling...</p>
<p>A few of these I would like to fix later on (like the comment formatting and error handling), but others I don't really care about (line length).
I'd also like to extend it to have more command-line options so it can format in-place instead of printing to standard out, but I'll probably work on that when I have the interpreter running since it won't matter until then.</p>
<p>And now it runs!
We can pass in a messy program like this:</p>
<pre data-lang="hurl" class="language-hurl "><code class="language-hurl" data-lang="hurl">let year = 2023; let greeting =
    &quot;Hurl was created in &quot; + year + &quot;!&quot;
    ;

let p = (func(x) { print(x); });
p(
    greeting);
</code></pre>
<p>And get out a clean program like this!</p>
<pre data-lang="hurl" class="language-hurl "><code class="language-hurl" data-lang="hurl">let year = 2023;
let greeting = &quot;Hurl was created in &quot; + year + &quot;!&quot;;

let p = (func(x) {
    print(x);
});
p(greeting);
</code></pre>
<p>As usual, the code is in <a href="https://git.sr.ht/~ntietz/hurl-lang/tree">the repo</a> if you want to take a look.</p>
<p>This project was harder than I anticipated, and I also learned a lot more than I expected to.
And now, like all serious languages, Hurl has a formatter.
Next up is the interpreter and a standard library.
After that... maybe a language server, and a package manager?</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>I work full-time, write as a hobby, and have two young kids at home. Free time is limited.</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>I think there are edge cases where this is not true, like if you have two functions which butt up against each other. They end up as siblings in the parse tree but they're more than 1 line apart, so my mechanism would detect blank lines here. This is okay for my formatter (I want blank lines there) but it's a happy accident, and I'm not happy about it.</p>
</div>
