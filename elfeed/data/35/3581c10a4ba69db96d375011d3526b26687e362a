<p>I've got a reputation at work as being a skilled debugger.
It's a frequent occurrence that the <em>weird stuff</em> lands on my desk<sup class="footnote-reference"><a href="#1">1</a></sup> after it goes through another skilled engineer or two.
To say my job is substantially &quot;debug the weird shit&quot; would not be an understatement and I'm here for it.</p>
<p>This extends throughout our codebase, and into code I haven't seen before at all.
I'm the longest tenured engineer at my company, so I'm familiar with most of our systems.
But I've lost track of most of the features that get deployed, and we have way more code changes than I can personally review.
And my debugging spans the stack: backend to frontend to database to weird Ubuntu behavior on our dev laptops.
(Yes, our principal engineer also does tech support, and again, I'm so here for it.)</p>
<p>So... How do I do it?
If I'm presented routinely with bugs I'm expected to solve in systems I'm unfamiliar with, what's the process?
And does it extend to things outside of code?</p>
<h1 id="general-approach-to-debugging">General approach to debugging</h1>
<p>My approach is systematic and focused on understanding first and foremost.
This is for a variety of reasons, but principally that you need to understand what is going on both to fix it and to be sure it's fixed.</p>
<p>Here's the process laid out in sequence.
After going through the steps, I'll provide more detail on each one.</p>
<ol>
<li>Figure out the symptoms.</li>
<li>Reproduce the bug.</li>
<li>Understand the system(s).</li>
<li>Form a hypothesis about where the bug is.</li>
<li>Test this hypothesis, and repeat if needed.</li>
<li>Fix the bug! Check the fix, and repeat if needed.</li>
</ol>
<p>We go through quite a bit of this process before even touching code.
This can feel counter-intuitive and is difficult to get in the habit of, because the instinct is to dive right into the code (reading it and modifying it).
Let's dive into each of these steps in more detail.</p>
<h2 id="1-figure-out-the-symptoms">1. Figure out the symptoms</h2>
<p>First you have to figure out the symptoms: what's the bad behavior that's being read as a bug?
What behaviors are happening that shouldn't, what's going wrong?</p>
<p>This one sounds obvious but it's a step people skip a lot.</p>
<p>If you get a bug report, the first thing to do is determine what it means <em>precisely</em>.
In the best case scenario you will have a well-written issue description already from either the bug reporter or a colleague who triaged it, but even in this case take some time to digest it.
Sit with the bug report and understand what behavior you're trying to address, and play around with the software in question as well.</p>
<p>If you don't understand the bug behavior, you have <em>no hope</em> of knowing if you've fixed it or not.
You can't even get started reproducing it!
So this is a crucial step to start with.</p>
<p><strong>Questions to ask:</strong></p>
<ul>
<li>When did the bug start happening?</li>
<li>How many people have experienced it? Reported it?</li>
<li>Who noticed it first?</li>
<li>What environments does it occur in?</li>
</ul>
<h2 id="2-reproduce-the-bug">2. Reproduce the bug</h2>
<p>After you know what the bug <em>is</em>, you sit down and try to reproduce it.
I like to reproduce bugs first in the same environment it was originally seen in, as long as it's safe to do so.
You don't want to mess up real user data in production, but if you can reproduce the bug without harm, definitely do so.</p>
<p>From there, I like to reduce the reproduction to as minimal steps as possible.
This is also where you can start moving it into environments where you have more control and better tools to inspect the system with<sup class="footnote-reference"><a href="#2">2</a></sup>.</p>
<p>Each struggle to reproduce the bug tells you more about the bug!
If you try to reduce the reproduction to something smaller, you'll find pieces that are essential for reproducing it (does it happen with all user types, or a particular user type? all workspaces, or one workspace?) and those that are incidental.
This is a starting point for understanding what's going on and will give you hints about what could be the cause.</p>
<p>Sometimes reproducing the bug can be vexingly difficult.
It's necessary: <em>don't skip this</em>.
If you cannot reproduce the bug, you cannot confirm whether it's fixed or not.</p>
<p>Some bugs will be reproducible <em>sometimes</em> (especially the case for race condition-based bugs).
If that's the case, work to get the reproduction as reliable as possible, and measure the reproduction.
If it happens 1/20 times vs if it happens 1/2 times, it's harder to be confident that you fixed it and didn't just make it less likely.
And when it's truly only reproducible sometimes, automating and measuring your reproduction can give a good way to <em>measure</em> your progress on the bug.
You can let your automation rip through 10x the necessary cases for reproducing it and see if you really, truly did fix it. Probably.</p>
<h2 id="3-understand-the-system-s">3. Understand the system(s)</h2>
<p>Now that we understand what the bug is and we can reproduce it, we can take a step back to understand the system as a whole.
The instinct at this stage will be to jump in and start doing &quot;proper&quot; debugging with your debugger; resist this temptation, it will bite you.
It's better to take a step back and understand the system first.</p>
<p>Some of this will be in your head already if you're working in a familiar codebase, but it is beneficial to go through what pieces and parts are involved here.
It will refresh your mental model of the system and load things up into your memory to help you form connections between different components involved.</p>
<p>These are some of the questions I like to know the answers to when debugging web applications (analogues exist for other software):</p>
<ul>
<li>What code is currently running?</li>
<li>When was it last deployed?</li>
<li>What were the recent changes?</li>
<li>Does the appearance of the bug coincide with a deployment or another change?</li>
</ul>
<p>You will also want to look at your logs and observability tools and breathe them in.
You can start with the logs that are relevant to <em>this</em> error, but you also want to find the logs that are just &quot;normal&quot;.
If you don't look at the normal logs, you won't know what normal logs look like; maybe that error you're seeing is actually benign and a bad log message, or maybe it's related!
If you don't look at normal distributed traces, you won't know what weird ones look like!
Until you've gotten your pattern matching for what's normal, you can't tell what's an outlier.
So read through a bit, skim a bit, and let your brain do some pattern matching to prime you for deeper diving.</p>
<h2 id="4-form-a-hypothesis-about-the-location-of-the-bug">4. Form a hypothesis about the <em>location</em> of the bug</h2>
<p>Now we know enough to start figuring out where the bug is.
Note that at this step we're not worried about <em>what</em> the bug is, but <em>where</em> it is:
Which component of our system is causing this bug?
Which module of that component is doing something naughty?</p>
<p>The main point of this is <em>narrowing the search space</em>.
Production systems are usually far larger than we can fit in our heads at one time.
By narrowing it down, we can make the context small enough to be able to work more effectively.</p>
<p>So, what we do is form a hypothesis of <strong>where the bug is</strong>.
Some questions that we can form hypotheses around:</p>
<ul>
<li>Which component of our system contains the bug? Is it just one, or multiple?</li>
<li>Is the bug in the component, or in the interactions between components?</li>
</ul>
<p>Early on, you want to bisect the system.
Make a hypothesis that allows you to eliminate as many locations as possible, ideally close to 50% of the system.
This lets you do a sort of binary search for the bug and make rapid progress narrowing it down.</p>
<h2 id="5-test-your-hypothesis">5. Test your hypothesis</h2>
<p>Once you have a hypothesis about where the bug is, you can test the hypothesis.
Locate the component in question and validate input/output.
Is the bug here, or is it somewhere else?</p>
<p>This can be tricky and nuanced, because you might not have full visibility into what's going on to test your hypothesis.
Don't be afraid to <em>modify what's running</em> to get more information!
A lot of people are nervous to do this, but it's important to remember: <strong>the power of software is that we can <em>change</em> it</strong>, including adding more debug logs.
Just make sure you reproduce the bug again after your modifications, otherwise your changes may hide the bug even if apparently unrelated<sup class="footnote-reference"><a href="#3">3</a></sup>.</p>
<p>Now we repeat until we find the location of the bug and zero in on it.
Whether you validate or invalidate your hypothesis, you gain information which lets you construct another, narrower, hypothesis!
We keep going back to forming hypotheses (or gathering more information) until we are quite close to the bug.
As you repeat, you may shift from location to behavior-based hypotheses; this is natural and okay as long as you keep gaining information and not just ruling out one particular cause of the bug.</p>
<h2 id="6-fix-the-bug">6. Fix the bug!</h2>
<p>Now we get to the final stage.
We know what the bug is, how to reproduce it, how the system works, and where the bug is.
All that's left is to fix it!</p>
<p>This is hopefully the easy part once you've gotten here.
If it's a &quot;simple&quot; bug, then this is straightforward coding.
Sometimes the bug belies a deficiency in the design of the system, and then it's a lot more challenging to fix, but at least you're armed with the information you need to fix or mitigate it.</p>
<p>This stage may also sometimes kick you back to an earlier stage, if attempting to fix it reveals that it's not where you thought or that there are other interacting pieces.
You might be going back and repeating steps, but it's all forward progress.
Repeat as many times as needed.</p>
<hr />
<p>That's my general process!
One of the things I like about it is that it isn't specific to software at all, outside of tools you choose to use.
You can apply this process to debugging systems in general, and it's a good systematic approach to problem solving.
You learn a <em>lot</em> along the way, too!</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>When I returned from my sabbatical at RC, there were a couple of bugs where people said &quot;oh, we were saving this one for when you got back!&quot;</p>
</div>
<div class="footnote-definition" id="2"><sup class="footnote-definition-label">2</sup>
<p>This does assume that you have less restricted access on your local environment than production. You don't have root in prod... right?</p>
</div>
<div class="footnote-definition" id="3"><sup class="footnote-definition-label">3</sup>
<p>Gotta love these ones, and there's a term for them: <a href="https://en.wikipedia.org/wiki/Heisenbug">Heisenbugs</a>.</p>
</div>
