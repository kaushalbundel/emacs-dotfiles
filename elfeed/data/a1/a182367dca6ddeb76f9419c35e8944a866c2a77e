<p>Denote aims to be a simple-to-use, focused-in-scope, and effective
note-taking and file-naming tool for Emacs.</p>

<p>Denote is based on the idea that files should follow a predictable and
descriptive file-naming scheme.  The file name must offer a clear
indication of what the contents are about, without reference to any
other metadata.  Denote basically streamlines the creation of such
files or file names while providing facilities to link between them
(where those files are editable).</p>

<p>Denote’s file-naming scheme is not limited to “notes”.  It can be used
for all types of file, including those that are not editable in Emacs,
such as videos.  Naming files in a constistent way makes their
filtering and retrieval considerably easier.  Denote provides relevant
facilities to rename files, regardless of file type.</p>

<ul>
  <li>Package name (GNU ELPA): <code class="language-plaintext highlighter-rouge">denote</code></li>
  <li>Official manual: <a href="https://protesilaos.com/emacs/denote">https://protesilaos.com/emacs/denote</a></li>
  <li>Change log: <a href="https://protesilaos.com/emacs/denote-changelog">https://protesilaos.com/emacs/denote-changelog</a></li>
  <li>Git repo on SourceHut: <a href="https://git.sr.ht/~protesilaos/denote">https://git.sr.ht/~protesilaos/denote</a>
    <ul>
      <li>Mirrors:
        <ul>
          <li>GitHub: <a href="https://github.com/protesilaos/denote">https://github.com/protesilaos/denote</a></li>
          <li>GitLab: <a href="https://gitlab.com/protesilaos/denote">https://gitlab.com/protesilaos/denote</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Mailing list: <a href="https://lists.sr.ht/~protesilaos/denote">https://lists.sr.ht/~protesilaos/denote</a></li>
  <li>Video demo: <a href="https://protesilaos.com/codelog/2022-06-18-denote-demo/">https://protesilaos.com/codelog/2022-06-18-denote-demo/</a>.</li>
  <li>Backronyms: Denote Everything Neatly; Omit The Excesses.  Don’t Ever
Note Only The Epiphenomenal.</li>
</ul>

<p>Below are the release notes.</p>

<hr />

<p>The present version covers four broad themes:</p>

<ol>
  <li>Denote rename commands are more user-friendly and featureful.</li>
  <li>An optional sorting facility makes it possible to produce a
filtered and sorted Dired buffer with Denote files.</li>
  <li>The optional Denote Org dynamic blocks have received a lot of attention.</li>
  <li>Bug fixes and internal refinements.</li>
</ol>

<p>[ Remember that you do not need to be a programmer to contribute to
  Denote. Report a bug, make a suggestion, or just describe how you
  want to use this package. Every idea counts and we may implement it
  if we can. ]</p>

<h2>The rename commands can remove a Denote file name component</h2>

<p>The commands we provide to rename files using the Denote file-naming
scheme—<code class="language-plaintext highlighter-rouge">denote-rename-file</code>, <code class="language-plaintext highlighter-rouge">denote-dired-rename-files</code>, and
<code class="language-plaintext highlighter-rouge">denote-dired-rename-marked-files-with-keywords</code>—can now remove
Denote file name components. This is done by providing an empty string
at the relevant prompt.</p>

<p>For example, to remove the <code class="language-plaintext highlighter-rouge">TITLE</code> component from a file called
<code class="language-plaintext highlighter-rouge">20231209T110322==sig--title__keywords.ext</code> we provide an empty string
at the title prompt. The end result will look something like this:
<code class="language-plaintext highlighter-rouge">20231209T110322==sig__keywords.ext</code>.</p>

<p>All prompts now include a hint that leaving them empty will ignore the
given field if it does not exist or remove it if it does exist.</p>

<p>Note that you must <strong>check how to input an empty string</strong> with your
minibuffer user interface of choice. For instance, with the <code class="language-plaintext highlighter-rouge">vertico</code>
package you can do that with the <code class="language-plaintext highlighter-rouge">M-RET</code> key binding or by selecting
the prompt line directly (notice the counter showing something like
<code class="language-plaintext highlighter-rouge">*/5</code> instead of <code class="language-plaintext highlighter-rouge">1/5</code>). Please make sure to consult the documentation
of the package you are using as this behaviour is not controlled by
Denote. Vertico, and others like it, selects the first candidate if
you type <code class="language-plaintext highlighter-rouge">RET</code> without any input, which is not the same as an empty
string—it is the first candidate.</p>

<p>Also read the Denote manual on the matter of <a href="https://protesilaos.com/emacs/denote#h:532e8e2a-9b7d-41c0-8f4b-3c5cbb7d4dca">Renaming
files</a>.
In short, we use this facility to name all our files, regardless of
file type, in a consistent way that makes them easier to find (I do
this with my videos, for example, and I do it across my filesystem for
all personal files).</p>

<h2>The file-to-be-renamed is easier to read in the minibuffer</h2>

<p>The commands <code class="language-plaintext highlighter-rouge">denote-rename-file</code> and <code class="language-plaintext highlighter-rouge">denote-dired-rename-files</code>
show the name of the file they are operating on in the minibuffer
prompt. This is now produced relative to the current directory,
meaning that instead of <code class="language-plaintext highlighter-rouge">/some/rather/long/path/to/file-name.txt</code>
Denote only displays <code class="language-plaintext highlighter-rouge">file-name.txt</code>.</p>

<p>Our rename commands never move files to another directory, anyway, so
we do not need to remind the user of the entire file system path.</p>

<p>To make things easier for users/themes, file names highlighted in
Denote prompts are fontified with either of following faces,
depending on the specifics of the case:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">denote-faces-prompt-old-name</code></li>
  <li><code class="language-plaintext highlighter-rouge">denote-faces-prompt-new-name</code></li>
  <li><code class="language-plaintext highlighter-rouge">denote-faces-prompt-current-name</code></li>
</ul>

<p>These faces inherit the attributes of basic faces, so they should look
decent without further tweaks across all themes.</p>

<h2>Prompts for title, keywords, and signature accept an empty string</h2>

<p>The prompts defined by Denote that apply to file name components all
accept an empty string. This has the effect of skipping the given
component. For example, we can create a file without a title and
keywords, with the following sequence of actions (I assume you are
using <code class="language-plaintext highlighter-rouge">vertico</code> for the minibuffer user interface):</p>

<ul>
  <li>Type <code class="language-plaintext highlighter-rouge">M-x denote</code>.</li>
  <li>Type <code class="language-plaintext highlighter-rouge">M-RET</code> at the title prompt to input an empty string.</li>
  <li>Now type <code class="language-plaintext highlighter-rouge">M-RET</code> at the keywords prompt for another empty string.</li>
</ul>

<p>The resulting file name is something like <code class="language-plaintext highlighter-rouge">20231209T110950.org</code>.</p>

<h2>Dired with sorting and filtering</h2>

<p>The new optional <code class="language-plaintext highlighter-rouge">denote-sort.el</code> library provides facilities to sort
Denote files by any of their file name components. Users can benefit
from this facility to produce a filtered and sorted listing of Denote
files with the command <code class="language-plaintext highlighter-rouge">denote-sort-dired</code>.</p>

<p><code class="language-plaintext highlighter-rouge">denote-sort-dired</code> produces a fully fledged Dired buffer. It asks for a
regular expression that matches file names in the <code class="language-plaintext highlighter-rouge">denote-directory</code>.
It then prompts for a sort key and finally checks with the user
whether to reverse the order or not.</p>

<p>[ Do not be discouraged by the term “regular expression”. Ordinary
  words work fine. Plus, with Denote’s file-naming scheme we have
  semantics such as <code class="language-plaintext highlighter-rouge">_keyword</code>, <code class="language-plaintext highlighter-rouge">-title</code>, <code class="language-plaintext highlighter-rouge">=signature</code>, as explained
  in the manual. This is the whole point of using a thoughtful naming
  scheme. ]</p>

<p>The resulting Dired listing is flat, meaning that files inside of
subdirectories are bundled together with those present at the root of
the <code class="language-plaintext highlighter-rouge">denote-directory</code>. In this case, files inside of a subdirectory
include the directory component as a prefix. So we have something like
this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>test-subdir/20230320T105950--a-new-note__testing.txt
20231202T095629--rename-works-as-intended__one_test_two.org
</code></pre></div></div>

<p>I think this is a killer feature, as the fully fledged Dired buffer
allows us to perform all supported operations on our Denote
sorted+filtered files (e.g. change file permissions, move files to
another directory, or open them in an external application).</p>

<p>I recorded a video to show how this works:
<a href="https://protesilaos.com/codelog/2023-12-04-emacs-denote-sort-mechanism/">https://protesilaos.com/codelog/2023-12-04-emacs-denote-sort-mechanism/</a>.</p>

<p>[ Remember that we can rename any file using the Denote file-naming
  scheme, meaning that our files can include stuff like PDFs and
  videos. Combine this with the concept of “silos”, which is covered
  in the Denote manual, to organise your long-term storage and
  retrieve it efficiently. ]</p>

<h2>Combine contents of files with an Org dynamic block</h2>

<p>The new <code class="language-plaintext highlighter-rouge">denote-files</code> Org dynamic block produces a continuous stream
of file contents. It joins together the contents of files inside the
<code class="language-plaintext highlighter-rouge">denote-directory</code> whose name matches the given regular expression.
Optional parameters control whether to include links to those files,
omit their front matter, sort by a given file name component, or tweak
the separator between each file’s contents.</p>

<p>I produced a video to demonstrate the functionality:
<a href="https://protesilaos.com/codelog/2023-11-25-emacs-denote-org-dynamic-blocks/">https://protesilaos.com/codelog/2023-11-25-emacs-denote-org-dynamic-blocks/</a>.</p>

<p>Use the command <code class="language-plaintext highlighter-rouge">denote-org-dblock-insert-files</code> to insert such a
block directly at point. Read the Denote manual for the
technicalities: <a href="https://protesilaos.com/emacs/denote#h:f15fa143-5036-416f-9bff-1bcabbb03456">Org dynamic block to insert file contents</a>.</p>

<p>[ Videos I do will eventually be out-of-date. The manual is the source
  of truth. ]</p>

<p>Bear in mind that this feature is not “transclusion”. We are simply
printing a copy of the contents of the files in the current buffer.
Changes made to this copy are not reflected in the original files.</p>

<p>The <code class="language-plaintext highlighter-rouge">denote-files</code> Org dynamic block is an excellent way to quickly
collect your thoughts on a given topic. Although dynamic blocks are a
feature of Org, the contents of the files do not need to be in Org
syntax (I write most of my notes in plain text (<code class="language-plaintext highlighter-rouge">.txt</code>)).</p>

<p>Thanks to Claudiu Tănăselia for proposing this idea and discussing it
with me. This was done via a private channel and the information is
shared with permission.</p>

<h2>Sort parameters are used in all Denote Org dynamic blocks</h2>

<p>All Denote Org dynamic blocks make use of <code class="language-plaintext highlighter-rouge">denote-sort.el</code> (described
further above). It powers the <code class="language-plaintext highlighter-rouge">:sort-by-component</code> and <code class="language-plaintext highlighter-rouge">:reverse-sort</code>
parameters.</p>

<p>Thanks to Glenna D. for suggesting this feature and discussing it with
me. This was done via a private channel and the information is shared
with permission. It is what inspired me to start work on
<code class="language-plaintext highlighter-rouge">denote-sort.el</code>, which I then extended to cover Dired, as noted
above.</p>

<h2>The <code class="language-plaintext highlighter-rouge">:missing-only</code> parameter is removed from Org dynamic blocks</h2>

<p>I am removing it because the underlying functionality of
<code class="language-plaintext highlighter-rouge">denote-add-missing-links</code> was not always reliable.</p>

<h2>Files with signature are linked appropriately in Org dynamic blocks</h2>

<p>In general, we provide the command <code class="language-plaintext highlighter-rouge">denote-link-with-signature</code> to let
the user pick a file that has a signature and link to it. The
description of such a link contains the signature text as well as the
file title. The <code class="language-plaintext highlighter-rouge">denote-link-with-signature</code> is distinct from the
standard <code class="language-plaintext highlighter-rouge">denote-link</code>, as it allows the user to express intent about
the inclusion of the signature.</p>

<p>In Org dynamic blocks for links/backlinks, we make this happen
automatically since there can be no manual intervention to express
intent on a link-by-link basis.</p>

<h2>Fontification in Dired can now extend to subdirectories</h2>

<p>The user option <code class="language-plaintext highlighter-rouge">denote-dired-directories</code> activates the
<code class="language-plaintext highlighter-rouge">denote-dired-mode</code> in the specified list of directories when the user
sets this in their init file:</p>

<div class="language-elisp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nv">add-hook</span> <span class="ss">'dired-mode-hook</span> <span class="nf">#'</span><span class="nv">denote-dired-mode-in-directories</span><span class="p">)</span>
</code></pre></div></div>

<p>The new user option <code class="language-plaintext highlighter-rouge">denote-dired-directories-include-subdirectories</code>
extends the reach of this feature to all subdirectories thereof.</p>

<p>Thanks to Henrik Hörmann for discussing this with me and contributing
a patch. This was originally done in pull request 191 on the GitHub
mirror: <a href="https://github.com/protesilaos/denote/pull/191">https://github.com/protesilaos/denote/pull/191</a>. Subsequent
refinements by me.</p>

<h2>Signatures are sluggified as intended</h2>

<p>The file name signature component is now sluggified properly. This
means that multiple words are separated by the equals sign, in
accordance with the Denote file-naming scheme where a word separator
is the same as the given field separator (this is the low-tech feature
that makes Denote files so easy to retrieve without fancy extras).</p>

<p>Vedang Manerikar fixed two relevant bugs in the “rename” commands,
while I rewrote internal functions and tests in the interest of consistency. Vedang’s patches: <a href="https://lists.sr.ht/~protesilaos/denote/patches/46790">https://lists.sr.ht/~protesilaos/denote/patches/46790</a>.</p>

<p>[ The “signature” is a free form component of the file name. Users can
  add anything they want there, such as to use it as a “category” that
  is different from “tags/keywords”, or to introduce sequences in
  their notes, or to just have an extra marker for files they need to
  spot quickly. ]</p>

<h2>For developers</h2>

<p>There is a section in the manual titled “For developers or advanced
users”. There we document functions or variables that are
public-facing, meaning that we test and document their behaviour and
encourage others to use them for code they write on top of Denote.
Refer to this section if you are looking to extend Denote. Though you
can also just check the source code, which is designed to be readable
and hackable.</p>

<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">denote-directory-files</code> function gains new functionality that
subsumes that of the now-deprecated functions
<code class="language-plaintext highlighter-rouge">denote-directory-files-matching-regexp</code>, <code class="language-plaintext highlighter-rouge">denote-all-files</code>,
<code class="language-plaintext highlighter-rouge">denote-directory-text-only-files</code>. Thanks to Jean-Philippe Gagné
Guay for the contribution, which was done in pull request 195 on the
GitHub mirror: <a href="https://github.com/protesilaos/denote/pull/195">https://github.com/protesilaos/denote/pull/195</a>.</p>
  </li>
  <li>
    <p>The font-lock keywords we define are consolidated into a single
variable: <code class="language-plaintext highlighter-rouge">denote-faces-file-name-keywords</code> instead of being split
into two variables. This means that we cover all our fontification
needs in the backlinks buffer as well as the <code class="language-plaintext highlighter-rouge">denote-dired-mode</code>
with this one point of entry. It also works for <code class="language-plaintext highlighter-rouge">denote-sort-dired</code>,
which can include files with their subdirectory component in the
same flat listing.</p>
  </li>
  <li>
    <p>Use the function <code class="language-plaintext highlighter-rouge">denote-retrieve-filename-keywords</code> to extract
keywords from the file name alone, without going into the file
contents.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">denote-retrieve-filename-title</code> function now returns an empty
string if no title is present. Its behaviour is thus consistent with
<code class="language-plaintext highlighter-rouge">denote-retrieve-filename-keywords</code> and <code class="language-plaintext highlighter-rouge">denote-retrieve-filename-signature</code>.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">denote-retrieve-filename-title</code> will now use the
<code class="language-plaintext highlighter-rouge">file-name-base</code> function as a fallback subject to a non-nil
optional argument. This case come into effect when the file does not
have a title component. The new optional argument allows the caller
to handle such cases as they see fit.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">denote-signature-prompt</code> and <code class="language-plaintext highlighter-rouge">denote-title-prompt</code> functions
accept an optional <code class="language-plaintext highlighter-rouge">DEFAULT-SIGNATURE</code> or <code class="language-plaintext highlighter-rouge">DEFAULT-TITLE</code> argument.
Internally, this is used as the <code class="language-plaintext highlighter-rouge">INITIAL-INPUT</code> of <code class="language-plaintext highlighter-rouge">completing-read</code>
instead of the <code class="language-plaintext highlighter-rouge">DEF</code> argument. This matters because we want the
prompt to return an empty string if there is no input, whereas the
presence of <code class="language-plaintext highlighter-rouge">DEF</code> means that <code class="language-plaintext highlighter-rouge">DEF</code> is returned when the prompt is
empty.</p>
  </li>
  <li>
    <p>All our functions that interactively match file names with a regular
expression now use the <code class="language-plaintext highlighter-rouge">denote-files-matching-regexp-prompt</code>
function. When called from Lisp, it takes a <code class="language-plaintext highlighter-rouge">REGEXP</code> argument as
well as an optional <code class="language-plaintext highlighter-rouge">PROMPT-TEXT</code>.</p>
  </li>
</ul>

<p>For the purposes of this release cycle, I am not documenting the
points of entry provided by <code class="language-plaintext highlighter-rouge">denote-sort.el</code>. It is a new feature that
I may eventually incorporate in <code class="language-plaintext highlighter-rouge">denote.el</code>. If you are interested in
the functionality (e.g. to have more elaborate sorting algorithms),
please take a look at the source code and then let us discuss the
implementation details.</p>

<h2>Miscellaneous</h2>

<ul>
  <li>
    <p>Rewrote the manual on the topic of Org dynamic blocks. Same idea for
practically the entirety of <code class="language-plaintext highlighter-rouge">denote-org-dblock.el</code>.</p>
  </li>
  <li>
    <p>Marked the interactive specification of a few commands with the
major mode they belong to. This means that <code class="language-plaintext highlighter-rouge">M-X</code> (note the capital
X), which calls <code class="language-plaintext highlighter-rouge">execute-extended-command-for-buffer</code> by default,
will only show those commands in the relevant context.</p>
  </li>
  <li>
    <p>Made internal refinements and simplified the implementation of a few
functions. This is important work to keep the code base clean and
easy to read/maintain. Thanks to Jean-Philippe Gagné Guay for the
contribution. It was done in pull request 193 on the GitHub mirror:
<a href="https://github.com/protesilaos/denote/pull/193">https://github.com/protesilaos/denote/pull/193</a>.</p>
  </li>
  <li>
    <p>Improved the doc string of the <code class="language-plaintext highlighter-rouge">denote-format-file-name</code> function.
Also introduced a unit test for it to be sure it does what we expect
(I eventually want to have tests for everything we do, but this is a
long-term project).</p>
  </li>
</ul>

<h2>Git commits</h2>

<p>Just an overview of what we did. Thanks again to everyone involved.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/Git/Projects/denote $ git shortlog 2.1.0..2.2.0 --summary --numbered
   125	Protesilaos Stavrou
    17	Jean-Philippe Gagné Guay
     2	Vedang Manerikar
     1	Henrik Hörmann
</code></pre></div></div>

<h2>Policy for the next development cycle</h2>

<p>I will give a ~1 week pause on Denote development before making any
feature changes. This is to ensure that we catch possible bugs and
push fixes right away. If there are other changes in place, it is not
possible to make point updates of this sort, as we must first wait for
the new features to be tested in real-world scenaria.</p>