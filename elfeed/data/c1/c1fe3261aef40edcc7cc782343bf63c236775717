<p>Recently while reading Real-World Cryptography, I got nerd sniped<sup class="footnote-reference"><a href="#nerd-sniped">1</a></sup> by the mention of <a href="https://en.wikipedia.org/wiki/Padding_oracle_attack">Bleichenbacher's attack on RSA</a>.
This is cool, how does it work?
I had to understand, and to understand something, I usually have to build it.</p>
<p>Well, friends, that is what I did.
I implemented RSA from scratch, wrote the attack to decrypt a message, and made a web demo of it.
Here's how I did it, from start to finish.</p>
<p>If you're here for <a href="https://www.ntietz.com/demos/bleichenbacher/">the demo</a>, feel free to peruse it before, during, or after reading this post!
It's a lot of fun.
Otherwise, buckle in for a fun ride.</p>
<h1 id="what-even-is-the-bleichenbacher-attack-wait-what-is-rsa">What even is the Bleichenbacher attack? Wait, what is RSA?</h1>
<p>Okay, so let's take a step back.
RSA itself is a cryptosystem that's, unfortunately, still widely used despite it being a bad idea to use it.
That's covered in my <a href="/blog/rsa-deceptively-simple/">post about RSA</a>, which gives a nice overview.
And the Bleichenbacher attack is a famous way to take an RSA-encrypted message<sup class="footnote-reference"><a href="#with-pkcs">2</a></sup> and find what it means without having the private key.</p>
<p>When I learned about the Bleichenbacher attack, I wanted to know how it worked in <em>detail</em>, not just broad strokes.
So I went to the source, the <a href="https://link.springer.com/content/pdf/10.1007/BFb0055716.pdf">paper he wrote</a> in 1998.
The paper contains a lot of math, but it's surprisingly approachable as long as you're looking to understand how to <em>implement</em> the attack.
Why it works, and the math derivations? I dunno.
But how it works in practice, algorithmically? Approachable!</p>
<p>After I read the paper, though, I realized I needed to know more—a lot more—about how RSA itself works.
So I read the <a href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA page on Wikipedia</a> a couple of times and worked through some examples by hand with very small numbers.
Comfortable that I understood it more or less, I turned back to the paper.</p>
<p>That's when I remembered that the paper was talking about a particular encoding scheme used with RSA, called <a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS #1 v1.5</a>.
So I had to read about that, too.
Then I read the paper <em>again</em> in that context, and was ready to dive in.</p>
<p>I came up with a plan of attack, pun intended:</p>
<ul>
<li><strong>Implement RSA.</strong> I wanted to do this myself so I can use very small keys and small messages, which would be faster to attack, so that I would know more quickly if my attack works or not. A lot of existing implementations strongly discourage, or prevent, using the vulnerable stuff, which was kind of the <em>point</em> here.</li>
<li><strong>Implement the attack.</strong> Then it would just be code up the paper, right? How hard could it be, right?</li>
<li><strong>Make a web demo!</strong> This was always the end goal, so it influenced the design from the beginning. I don't want to ship Python to the browser, for example.</li>
</ul>
<h1 id="implementing-rsa">Implementing RSA</h1>
<p>Writing my own RSA library was definitely a good choice for learning.
I <em>strongly</em> recommend people do this for fun and education, and also please license it under something that discourages usage unless you're actually getting it vetted and checked.</p>
<p>For my library, <a href="https://crates.io/crates/cryptoy">cryptoy</a>, I used Rust so that I could use that sweet WASM toolchain.
This would let me build it for the web and make an interactive demo!</p>
<p>I built it once, then rebuilt it again to make the interfaces better.
And then I realized that the bigint library I was using was going to make things difficult for the demo I wanted, so I migrated to a different one.
I was originally using <a href="https://crates.io/crates/crypto-bigint">crypto-bigint</a>, which is probably the one you want for any real cryptography applications in Rust, because it uses constant time operations wherever possible.
The challenge was that it requires fixed precision<sup class="footnote-reference"><a href="#runtime-precision">3</a></sup>, and that meant that it would be tough to write something that handles both very small and very large keys.</p>
<p>So, I migrated to use <a href="https://crates.io/crates/num-bigint-dig">num-bigint-dig</a>.
It has bigints with arbitrary precision at runtime, exactly what I want.
It library seems reasonable for my purposes, but doesn't have the vetting that <code>crypto-bigint</code> does, so I'd be more wary of it in production.
It very well could be fine, but it hasn't been audited and I <em>don't know</em> if there are problems.
But given that the whole <em>point</em> here is to produce something vulnerable to a particular attack?
Yeah, I'm okay with that.</p>
<p>The other point in favor of <code>num-bigint-dig</code> was that it had nice things built in, like generating random primes.
These were needed and I didn't have to go looking for them, so it makes the code nicer and tighter.
The ergonomics of the code also feel better, which is subjective.</p>
<p>After I implemented RSA, I started to build a demo of it in a little playground.
I got started, but didn't finish it.
It was really fun pairing with a friend on this for a bit, and ultimately I didn't find the thing that would make it a compelling demo, so it was dropped.
But like <a href="https://en.wikipedia.org/wiki/Chekhov%27s_gun">Chekov's gun</a>, will it return?</p>
<h1 id="implementing-the-attack">Implementing the attack</h1>
<p>The attack itself was pretty easy to get <em>partially</em> working, and then very challenging to flush the bugs out of.
It would make progress, make progress, then stall.
At some point I figured out that the problem related to rounding (in part by looking at other implementations, and mostly by squinting at the paper a lot).
Somewhere, my rounding went wrong.
I fixed it, <em>mostly</em>.
Then I rewrote it again and it worked!
I'm still not sure what the difference was and I'm not looking back to figure out.</p>
<p>That part was left with one fatal bug which annoying but I accepted, just to be done with the project: keys over a certain size would just totally fail!
Except I couldn't really let it go, it kept bugging me.
Eventually I realized that my iteration counter was an 8-bit int, for reasons that escape me<sup class="footnote-reference"><a href="#int">4</a></sup>.
The upshot of that was that every 256th iteration, my code thought it was at iteration 0, and it reset things.
Once that was a larger type, bigger keys worked!</p>
<p>Once it was done and I had it output some stats like the number of iterations taken and the number of messages required, I was pretty sure there was a bug: this was converging <em>too</em> fast, yeah?
But it turns out, it's actually fine!
There's <a href="https://ethz.ch/content/dam/ethz/special-interest/infk/inst-infsec/appliedcrypto/education/theses/Experimenting%20with%20the%20Bleichenbacher%20Attack%20-%20Livia%20Capol.pdf">a thesis</a> which shows that my messages required are about in the ballpark when using the kind of oracle<sup class="footnote-reference"><a href="#oracle">5</a></sup> I have.</p>
<p>The original paper called for an oracle which requires the padding to entirely be valid, but later results use a different oracle which just checks for two bytes at the start, <code>0x00 0x02</code>.
It was shown in <a href="https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-bock.pdf">Bock '18</a> that a <em>lot</em> of real-world cases of this attack provide this sort of oracle.
So, this is a realistic assumption.</p>
<p>After this was done, I built another version of it as an iterator.
I used the original code and encoded the state into an iterator so that, for a demo, I can show the progress and intermediate internal state along the way.
Converting it to an iterator was fun, and pretty straightforward!
It's a nice technique for looping algorithms, so that you have pause points between iterations where you can do other work.</p>
<h1 id="making-the-demo-it-s-yew-and-me">Making the demo: it's Yew and me</h1>
<p>To make the demo, I first procrastinated by looking at all the different Rust single-page app frameworks for an hour or two under the premise of &quot;research&quot;.
Then I decided to just use the one I already used on a different project, a framework called <a href="https://yew.rs/">Yew</a>.</p>
<p>I sketched out the design and figured out that what I wanted was something where you can see different steps along the way, but more importantly, get a <em>feel</em> for how the attack is progressing.
I wanted you to <em>feel how fast</em> it is to decrypt one of these messages.</p>
<p>From there I just worked through it.
Most of the code is boilerplate, lots of state hooks and forms passing data back out for later use.
The code is <a href="https://git.sr.ht/~ntietz/cryptoy/tree/main/item/playground">all available</a> if you do want to read it, so if you are curious, take a look!
The most interesting part is probably the container for the attack itself.
I needed to keep some state in there for where we are in the attack, and also needed to have it run on its own.</p>
<p>That state was kept inside the <code>AttackDemo</code> struct.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">#[derive(Debug)]
pub struct AttackDemo {
    &#x2F;&#x2F;&#x2F; internal state, and the iterator for the attack
    pub attack_state: AttackState,

    &#x2F;&#x2F;&#x2F; stats we want to display
    pub iterations: usize,
    pub oracle_calls: usize,
    pub span: BigUint,

    &#x2F;&#x2F;&#x2F; a ticker which gives us a call every so often
    pub ticker: Option&lt;Interval&gt;,
}
</code></pre>
<p>Then I implement Yew's <code>Component</code> trait for it.
We start with the associated types: we have <code>Msg</code> for the different messages we can send upon events, and a properties type for what's passed into the component.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">impl Component for AttackDemo {
    type Message = Msg;
    type Properties = AttackProps;

    &#x2F;&#x2F; ...
}

pub enum Msg {
    Step,
    Run,
    Pause,
    Reset,
}

#[derive(Properties, PartialEq)]
pub struct AttackProps {
    pub attack_state: AttackState,
}
</code></pre>
<p>Then we have the methods.
The <code>create</code> and <code>view</code> functions are boilerplate, just initializing the state and rendering some HTML with buttons for emitting different messages.
A stripped down form of <code>view</code> to just contain one button which sends a message would look like this.
The rest of it is similar to add more buttons, and render some data which we get from <code>self</code>.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">    def view(&amp;self, ctx: Context&lt;Self&gt;) -&gt; Html {
        let run = ctx.link().callback(|_| Msg::Run);

        html! {
            &lt;div class=&quot;attack&quot;&gt;
                &lt;input type=&quot;button&quot; value=&quot;Run&quot; onclick={run} &#x2F;&gt;
            &lt;&#x2F;div&gt;
        }
    }
</code></pre>
<p>The <code>update</code> function is where the attack code is invoked!
It looks like this.
We receive a message, and then pattern match on it.
For <code>Step</code>, we perform one iteration and cancel the ticker if we've exhausted the iterator.
For <code>Run</code>, we start a ticker for every 20 milliseconds (faster and you can't see the attack progress).
<code>Pause</code> does the opposite, and stops the ticker. And <code>Reset</code> clears all the state so we can start over!</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">    fn update(&amp;mut self, ctx: &amp;Context&lt;Self&gt;, msg: Self::Message) -&gt; bool {
        match msg {
            Msg::Step(n) =&gt; {
                if let Some((_message, state)) = self.attack_state.attack_iter.next() {
                    self.set_iteration_state(&amp;state);
                    true
                } else {
                    self.ticker = None;
                    false
                }
            }
            Msg::Run =&gt; {
                self.ticker = {
                    let link = ctx.link().clone();
                    Some(Interval::new(20, move || {
                        link.send_message(Msg::Step(1));
                    }))
                };
                true
            }
            Msg::Pause =&gt; {
                self.ticker = None;
                true
            }
            Msg::Reset =&gt; {
                self.ticker = None;
                self.reset_state(&amp;ctx.props().attack_state.current);
                self.attack_state = ctx.props().attack_state.clone();
                true
            }
        }
    }
</code></pre>
<p>While working on it, I had to remember to use release builds for larger key sizes as I was testing, otherwise my computer got really hot and things never finished.
Then again, it was pretty cold outside... so that was sometimes a benefit.</p>
<p>The final step was to create the release build and put it in a page on my blog!
This was pretty straightforward, though I have some manual steps.
There's not a good way that I can see to have <a href="https://trunkrs.dev/">Trunk</a> build artifacts you can embed into another page; it wants to build <em>the</em> page, and have other things embed into it.
Since I wanted to use my usual blog templates, I snagged out the pieces that I wanted from there, all good.</p>
<hr />
<p>This was a really fun project, end to end!
I don't think I would use Yew in production, because I am just not as productive in it as other things.
And I <em>certainly</em> wouldn't use my own RSA code (or any other RSA) in production!
But the point was to learn and have fun, and that was well achieved.</p>
<p>Now if you haven't gone and played with <a href="https://www.ntietz.com/demos/bleichenbacher/">the demo</a>, please do!</p>
<hr />
<div class="footnote-definition" id="nerd-sniped"><sup class="footnote-definition-label">1</sup>
<p>This term comes from a classic <a href="https://xkcd.com/356/">xkcd comic</a>. I wish we had a name for it that didn't evoke any violence, but it's the most well-known term for the phenomenon that I'm aware of, so I'm using it here for clarity.</p>
</div>
<div class="footnote-definition" id="with-pkcs"><sup class="footnote-definition-label">2</sup>
<p>It requires that the message be encoded in a particular format, called PKCS #1 v1.5. There are similar vulnerabilities for other encoding schemes, though not all encoding schemes have these.</p>
</div>
<div class="footnote-definition" id="runtime-precision"><sup class="footnote-definition-label">3</sup>
<p>There's a <code>BoxedUint</code> type available which decides precision at runtime, but I ran into problems getting a lot of things to work with these. I don't remember details and it could have been user error, but it was not the clear blessed path.</p>
</div>
<div class="footnote-definition" id="int"><sup class="footnote-definition-label">4</sup>
<p>I <em>think</em> it was because it was originally a <code>BigUint</code>, which I would declare using <code>let iteration: BigUint = 0u8.into();</code>, with the type specifier being required on the in here since <code>i32</code> can't be converted to <code>BigUint</code>. But then I made it not-a-BigUint since it doesn't need bigint-worth of iterations so let's save some cycles—and I didn't change it from <code>0u8</code>, leaving me with an 8-bit int.</p>
</div>
<div class="footnote-definition" id="oracle"><sup class="footnote-definition-label">5</sup>
<p>In this context, an oracle is something which you can ask &quot;is the plaintext for this ciphertext properly formatted in PKCS?&quot; and it will say &quot;yes&quot; or &quot;no&quot;.</p>
</div>
