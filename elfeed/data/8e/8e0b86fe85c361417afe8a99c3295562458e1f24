<p class=" text-justify drop-cap">Recently, I talked about the challenges around improving <a class=" article-link" href="https://www.masteringemacs.org/article/combobulate-structured-movement-editing-treesitter">Combobulate</a>, my package that adds structured editing and movement to Emacs, so navigation is <a class=" article-link" href="https://www.masteringemacs.org/article/combobulate-intuitive-structured-navigation-treesitter">intuitive and works the way a human expects</a>. Briefly, instead of relying on elaborate guesswork that breaks easily, there is now a little mini-language that captures how to pluck the right node from the concrete syntax tree provided by tree-sitter, a library that makes it a snap to parse and access said tree of any language for which there is a supported grammar.</p><p class=" text-justify">Intuitive navigation is hard because if you ask a human developer to navigate up, down, left or right in their code, they can do so effortlessly, as there’s little ambiguity around, say, what constitutes the next “line of code”. Good luck asking a computer to make the right choice when it’s got a baker’s dozen of wildly different nodes to contend with. Hence the mini-language.</p><p class=" text-justify">But I’ve talked about <a class=" article-link" href="https://www.masteringemacs.org/article/combobulate-intuitive-structured-navigation-treesitter">that already</a>. You should read that article first, if you haven’t. So today I’d like to talk about a related issue: when you ask Combobulate to do something – say, cloning the node at point, and in effect duplicating a piece of code – and Combobulate can’t decide which node is the right one, because there’s more than one legitimate node to clone at point.</p><p class=" text-justify">The problem space is similar to intuitive navigation, but with a twist. When we navigate we have a limited number of sensible directions we can move (up, down, left, right) and the bindings to go with it – <code>C-M-n</code> to move to the next sibling, <code>C-M-u</code> to move up to a parent, etc. – and when we invoke them we’d expect Emacs to just, you know, go to the right place. You don’t <em>really</em> want annoying minibuffer prompts, banners, billboards, smoke signals, crop circles or much of anything else to petition you and impede your train of thought. You just want to scoot away and not have Emacs stop you to ask for directions.</p><p class=" text-justify">Fair enough. Combobulate goes to a lot of trouble to try and pick the right thing for you in most cases, whether you’re editing or moving. Sometimes, though, you must ask the user to make a choice.</p><p class=" text-justify">And what’s the best way to do that?</p><h2 id="decisions-decisions">Decisions, decisions…</h2><figure>
<img alt="" class=" center-block" src="https://www.masteringemacs.org/static/uploads/combobulate/combobulate-python-indent.gif" />
<figcaption>The indentation 'carousel' in action. Tapping <code>TAB</code> at the start of a statement and Combobulate will calculate all possible indentation levels and let you choose the one you want interactively.</figcaption>
</figure><p class=" text-justify">It’s a quagmire, really, because I’d had this issue multiple times where I really wanted some way of asking the user to make a choice. I had played around with the obvious contenders: some form of <code>completing-read</code> (Emacs’s way of doing <a class=" article-link" href="https://www.masteringemacs.org/article/understanding-minibuffer-completion">minibuffer completion</a>) and a hook to update the buffer as you browse through the candidates. It didn’t really work all that well as it assumes you have a completion system that lets you cruise through the candidates interactively. Not everyone uses that; default Emacs has you <code>TAB</code> endlessly to scratch out a completion like some sort of neolithic farm hand. So that method wouldn’t work well for people who use that type of completion, and it also has the annoying problem of feeling like it was the wrong tool for the job. What if someone uses Helm or any number of other completion systems?</p><p class=" text-justify">I brainstormed some other methods like a <a class=" article-link" href="https://www.masteringemacs.org/article/introduction-magit-emacs-mode-git">Magit</a> transient popup-like thing that you’d pick nodes from, but it also felt cumbersome and I couldn’t figure out how to get transient to do what I wanted it to do.</p><p class=" text-justify">So I did what I always do: I got bored and went off in search of something else to do.</p><p class=" text-justify">Right around that time I’d added a primitive version of “expand region”. It is a simple concept, really: given successive key presses, expand the region to incorporate larger and larger structural elements, starting from point. It’s a nifty way of picking things that ordinary Emacs methods struggle to do well at, though I never cared much for it pre-tree-sitter as I found it too imprecise. Lots of people love it, though, and I figured that it’d be super handy with tree-sitter, as it’s so granular, and I wanted to support a wide range of workflows. So I added a basic version in about 30 minutes, and off it went to Github.</p><figure>
<img alt="" class=" center-block" src="https://www.masteringemacs.org/static/uploads/combobulate/combobulate-expand-region.gif" />
<figcaption>Combobulate can expand the region with <code>M-h</code>. It highlights the item ahead of the current region,  to give you an idea of where you are going. A customizable feature to let you select by number is also enabled here, and Combobulate will show you how much it has selected in the tree view as well.</figcaption>
</figure><p class=" text-justify">A few days later I got a polite and <em>totally obvious in hindsight</em> request to make possible to <em>shrink</em> the region. It’s all too easy to overshoot your mark as you’re tapping away and, having done so, you’d have no recourse but to start from scratch. Argh. Terrible UX!</p><p class=" text-justify">So I put on my thinking cap and started wondering how I could crowbar something into <code>combobulate-mark-node-dwim</code> (bound to <code>M-h</code>) so it can toggle the direction and, I… I realized I should just re-use <em>another</em> feature I’d added some months prior: a node / region-based indentation command in Python that lets you interactively browse and select the indentation level you want your node or region to have. (Believe it or not, but Emacs’s crummy Python mode can’t cycle all possible indentations of a region. It’s madness. The crux of the code to build it is <em>right there</em>, too. No TS required at all.)</p><p class=" text-justify">The python indentation command (see above) acts like a carousel: keep moving in one or the other direction and you’ll wind up back where you started. That’s great for a wide range of things, particularly when you’re not sure how many finger taps away something is: is it two or <em>three</em> indentations I want? Tap a bit and find out, as your buffer updates automatically.</p><p class=" text-justify">The indentation command was also a bit ham fisted in some ways, but it was a huge improvement over the ghastly python-mode indentation logic you had before which involved manual tedium and <code>C-x TAB</code> to indent by column.</p><p class=" text-justify">I gambled that if I could file off the rough edges, and build some tooling around it into Combobulate, it could work well for a wide range of tasks. I sat down and spent a fair bit of time hammering out a system of rules and concepts that makes for, I think, a pleasant user experience. Carousel seems like as good a name for it as anything, so that’s what I’ll call it from now on.</p><p class=" text-justify">If you’re already using Combobulate you’ll of course be familiar with the carousel concept already as it’s been in Combobulate for quite a while.</p><h3 id="reading-a-key-vs-minibuffer-prompting">Reading a Key vs Minibuffer Prompting</h3><p class=" text-justify">Let me explain. There’s a philosophical view (and some who disagree with this) that certain user-facing actions in Emacs don’t require a full-blown <em>minibuffer prompt</em> and that <em>reading a key</em> is enough. Which one is the right choice is rarely too contentious, but in a few instances you could lean towards either method, and that’s usually where tempers flash.</p><p class=" text-justify">Reading a key is mechanically simple: you call <code>read-key</code> (or one of its close relatives) and Emacs will patiently wait for a <em>key</em>; any key or key sequence, really. There is no minibuffer history to contend with; recursive minibuffers don’t apply, so you can’t switch out of the minibuffer window, either. You can display a prompt, but the main focus is really about user anticipation: once you know how the command works, and you know it expects a key, you just type it and get on with it. It is about as zero-effort as requesting user input could ever be. It’s used in a wide range of contexts in Emacs today, and it’s perfect when all you need from a user is a key.</p><p class=" text-justify">The alternative is <em>minibuffer prompting</em> which is the all-singing, all-dancing prompt experience you know already.</p><p class=" text-justify">I want Combobulate’s carousel to read a key: the reason is that it means I can capture the key you typed and, if I decide I have no use for it, I can put the key back on the <code>unread-command-events</code>. I could in theory still do that with the minibuffer prompt, but I still have to deal with the fact that it’s a complex system designed for non-trivial user interactions.</p><p class=" text-justify">Reading a key is simpler, and that’s important because it meshes well with the idea that the carousel is there to offer a seamless transition in to, and out of it.</p><h3 id="seamless-transition">Seamless transition</h3><p class=" text-justify">If you want to expand the region with <code>M-h</code>, you probably want to follow that up with another key. Perhaps <code>C-w</code> to kill the region you just expanded. By <em>reading the key</em> I can separate <code>TAB</code> and <code>S-TAB</code> (to cycle to the next and previous choice in the carousel) from irrelevant keys the carousel does not care about. Then, by putting the key the carousel <em>does not</em> care about back into the event loop, you can have Emacs carry out what ever it was going to do as though the carousel wasn’t there at all.</p><p class=" text-justify">End result? You can hit <code>M-h</code> and tap, tap, tap and press any other key that is not recognized by the carousel, and it’ll just execute the key as though you’d never had the carousel at all. No transition; no annoying in-your-face “are you really sure?” prompting; and no thinking required. It behaves the way an experienced Emacs user would expect it to work, and as if you never had the carousel active, even though, there it is, indicating in the echo area that it’s active and awaiting your input.</p><h3 id="maintaining-your-tempo">Maintaining your tempo</h3><p class=" text-justify">I mentioned that <code>TAB</code> and <code>S-TAB</code> cycle nodes. But if you tap, say, <code>M-h</code> for the first time, the carousel interface appears, and you can then repeatedly type <code>M-h</code> again which is the same as pressing <code>TAB</code>. That way you don’t have to move your fingers away from the triggering key and that helps preserve tempo. It makes for a smoother and easier user experience as you don’t have to context shift: oh I hit <code>M-h</code> and now I have to <code>TAB</code> to expand.</p><p class=" text-justify">Because I look up the key in a boring, old <a class=" article-link" href="https://www.masteringemacs.org/article/mastering-key-bindings-emacs">keymap</a> it’s easy for anyone to come along and modify it if they want the carousel to use other keys. It also means I can add additional keys that only apply to specific commands: Combobulate’s expand region functionality lets you cycle between the next and previous candidates with <code>M-h</code> and <code>M-S-h</code>, respectively.</p><p class=" text-justify">The third reason why it’s useful to have the same key is that some operations are incredibly destructive and may leave your buffer in a “broken” state: the syntax is invalid, and tree-sitter may struggle to glue it back together. Having a cohesive view of the buffer at the beginning and operating on it from a clean slate is crucial.</p><h3 id="cohesion">Cohesion</h3><p class=" text-justify">Let’s say you’re deleting code as part of a refactoring operation you’re doing. As you go about doing it, you’re definitely going to leave your code in a broken state at some point. That’s all well and good: you’re a human, and you can fix it.</p><p class=" text-justify">Tree-sitter has error-correction built into its parser, but just because it can mend, and partially recover from, broken syntax, does not mean it leaves the resulting tree in a state where an automated tool like Combobulate can make sensible decisions.</p><p class=" text-justify">That’s particularly true of highly destructive operations like Combobulate’s <em>splicing</em> where you’re eliding text as you try to snip and glue two pieces of code back together: the code you’ve decided to keep, and the code <em>around</em> the code you’re keeping that the splice deleted. Think of HTML where you want to delete the outer tag but keep the things inside it - that’s one part of what you can do with splicing.</p><p class=" text-justify">The problem is, maybe you want to splice two times, but the first splice irrevocably breaks your code in such a way that you’d never be able to make it to the second splice. And how do you delete the “outer” something of any old random piece of code, anyway? Take a look at the figure below to see what I mean.</p><figure>
<img alt="" class=" center-block" src="https://www.masteringemacs.org/static/uploads/combobulate/combobulate-splice-go.gif" />
<figcaption><code>M-&lt;up&gt;</code> splices up, keeping the siblings, which in this case is one line of code, and then deletes successive parents until it's at the root of the buffer. Note that along the way it leaves the tree in a broken state.</figcaption>
</figure><p class=" text-justify">Combobulate can splice nearly anything into something else. But that doesn’t mean it makes <em>syntactic sense</em> to do so. Maybe you do want it in a broken state; perhaps you want to tweak something to make it legal syntax again. Combobulate can’t read your mind so it has to calculate all possible paths.</p><p class=" text-justify">If the splice up command – as it used to do – only went up one level, you could easily break the tree in such a way that you wouldn’t be able to splice again. A broken tree often begets an even more broken tree.</p><p class=" text-justify">To work around <em>that</em>, the carousel virtualizes editing and computes everything on the fly, starting from the clean slate your buffer is (presumably!) in when you first initiate the command.</p><h3 id="virtualized-editing">Virtualized Editing</h3><figure>
<img alt="" class=" center-block" src="https://www.masteringemacs.org/static/uploads/combobulate/combobulate-clone-dwim.gif" />
<figcaption><code>C-c o c</code> clones a node and, if there are ambiguities, Combobulate will let you cycle through all the choices and interactively preview the change it'll make to your buffer.</figcaption>
</figure><p class=" text-justify">This was one of the harder things to build.</p><p class=" text-justify">Tree-sitter generates your tree on-the-fly as you type. Every key press compels tree-sitter to rebuild all or parts of the tree. That is its main benefit, and a lot of work was put into making it fast enough for even the fastest typist to not experience any lag or latency.</p><p class=" text-justify">Unfortunately, if you ask for a node and subsequently edit the buffer, that node is invalidated and marked outdated. If you try to do anything with it – anything at all, even asking it for its type or where it was in the buffer – it throws an error in your face.</p><p class=" text-justify">So you can’t collect the node(s) you want at the start and then modify the buffer in-situ, like the indentation example above shows. The first tap would kill the old nodes (we changed the indentation!), and render that approach useless.</p><p class=" text-justify">Combobulate constructs proxy nodes, and almost every part of Combobulate will accept these proxy nodes in lieu of the real deal. They are slimmed-down versions of the real things, but they reify the most important things we’d want to cling to: the point range in the buffer; the type; the text contained therein; etc.</p><p class=" text-justify">So when you ask Combobulate to present a carousel it actually virtualizes the nodes before any sort of change can take place. It neatly skirts most issues and lets you write code that can in theory modify the buffer without worrying about your nodes expiring when you touch the buffer. Of course, modifying the buffer means you hold on to outdated information, and Combobulate is no oracle, so if you make substantial changes, the proxy nodes might be thoroughly useless.</p><p class=" text-justify">Luckily, that’s usually not a problem because of Combobulate’s refactoring display system.</p><p class=" text-justify">Part of the challenge around the proxy node thing is that most commands do small, localized editing operations: indent some code; expand an envelope; splice some code; clone a node. You get the idea.</p><p class=" text-justify">As you tap through the carousel’s list of valid nodes, it should show you what would happen if the transformation you asked for is carried out on the currently selected node.</p><p class=" text-justify">For this to work well, the carousel works in unison with Combobulate’s refactoring system. The latter sounds fancier than it really is: all it lets you do is describe simple transformations, and visual ones to aid users, to make to a buffer. Add in the carousel’s ability to use <em>undo change groups</em> to revert buffer changes between choices and you can have visible modifications made to your buffer that is properly restored as you cycle through the choices.</p><p class=" text-justify">I think it’s important that, if you ask a command to make changes to your buffer, and if there’s more than one way to make that change, that you can preview all possible options. Combine it with the carousel interface and you’re afforded a fair amount of slop when it comes to point positioning.</p><p class=" text-justify">And if you don’t like the change? You can hit <code>C-g</code>, as with most things in Emacs, to abort the command.</p><p class=" text-justify">So that’s the carousel interface. I think it makes it much easier to visualize what’s going to happen in a non-committal way, and at the same time scroll through the valid node choices available to you.</p>