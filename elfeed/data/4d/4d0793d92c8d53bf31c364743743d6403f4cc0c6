<span class="thumbnail"><img width="128" height="108" src="https://content.wolfram.com/sites/43/2023/09/multicomp-icon.png" class="attachment-thumbnail size-thumbnail wp-post-image" alt="" /></span><style>
article#postid-53756 h1 {max-width: 660px;}
</style>
<p><img class="aligncenter title="Expression Evaluation and Fundamental Physics" src="https://content.wolfram.com/sites/43/2023/09/multicomp-finalhero.png" alt="Expression Evaluation and Fundamental Physics" width="620" height="300" /></p>
<h2 id="an-unexpected-correspondence">An Unexpected Correspondence</h2>
<p>Enter any expression and it’ll get evaluated:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523unexpected1img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523unexpected1img1.png' alt='' title='' width='237' height='43'> </div>
</p></div>
<p>And internally—say in the <a href="https://www.wolfram.com/language/">Wolfram Language</a>—what’s going on is that the expression is progressively being transformed using all available rules until no more rules apply. Here the process can be represented like this:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523unexpected1img2_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523unexpected1img2.png' alt='' title='' width='112' height='290'> </div>
</p></div>
<p>We can think of the yellow boxes in this picture as corresponding to “evaluation events” that transform one “state of the expression” (represented by a blue box) to another, eventually reaching the “fixed point” 12.</p>
<p>And so far this may all seem very simple. But actually there are many surprisingly complicated and deep issues and questions. For example, to what extent can the evaluation events be applied in different orders, or in parallel? Does one always get the same answer? What about non-terminating sequences of events? And so on.<span id="more-53756"></span></p>
<p>I was first exposed to such issues more than 40 years ago—when I was working on the design of the evaluator for the <a href="https://writings.stephenwolfram.com/2013/06/there-was-a-time-before-mathematica/">SMP system</a> that was the forerunner of <a href="https://www.wolfram.com/mathematica/">Mathematica</a> and the Wolfram Language. And back then I came up with pragmatic, practical solutions—many of which we still use today. But I was never satisfied with the whole conceptual framework. And I always thought that there should be a much more principled way to think about such things—that would likely lead to all sorts of important generalizations and optimizations. </p>
<p>Well, more than 40 years later I think we can finally now see how to do this. And it’s all based on ideas from our <a href="https://www.wolframphysics.org/" target="_blank" rel="noopener">Physics Project</a>—and on a fundamental correspondence between what’s happening at the lowest level in all physical processes and in expression evaluation. Our Physics Project implies that ultimately the universe <a href="https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#time">evolves through a series of discrete events</a> that transform the underlying structure of the universe (say, represented as a hypergraph)—just like evaluation events transform the underlying structure of an expression.</p>
<p>And given this correspondence, we can start applying ideas from physics—like ones about spacetime and quantum mechanics—to questions of expression evaluation. Some of what this will lead us to is deeply abstract. But some of it has immediate practical implications, notably for parallel, distributed, nondeterministic and quantum-style computing. And from seeing how things play out in the rather accessible and concrete area of expression evaluation, we’ll be able to develop more intuition about fundamental physics and about other areas (like <a href="https://www.wolframscience.com/metamathematics/">metamathematics</a>) where the ideas of our Physics Project can be applied.</p>
<h2 id="causal-graphs-and-spacetime">Causal Graphs and Spacetime</h2>
<p>The <a href="https://reference.wolfram.com/language/tutorial/Evaluation.html">standard evaluator in the Wolfram Language</a> applies evaluation events to an expression in a particular order. But typically multiple orders are possible; for the example above, there are three:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img1.png' alt='' title='' width='452' height='209'> </div>
</p></div>
<p>So what determines what orders are possible? There is ultimately just one constraint: the causal dependencies that exist between events. The key point is that a given event cannot happen unless all the inputs to it are available, i.e. have already been computed. So in the example here, the <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img2.png' width= '62' height='12' align='absmiddle'></span> evaluation event cannot occur unless the <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img3.png' width= '65' height='12' align='absmiddle'></span> one has already occurred. And we can summarize this by “drawing a causal edge” from the <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img4.png' width= '65' height='12' align='absmiddle'></span> event to the <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img5.png' width= '62' height='12' align='absmiddle'></span> one. Putting together all these “causal relations”, we can make a <a href="https://www.wolframphysics.org/technical-introduction/additional-material/appendix-graph-types/" target="_blank" rel="noopener">causal graph</a>, which in the example here has the simple form (where we include a special “Big Bang” initial event to create the original expression that we’re evaluating):</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img6.png' alt='' title='' width='220' height='175'> </div>
</p></div>
<p>What we see from this causal graph is that the events on the left must all follow each other, while the event on the right can happen “independently”. And this is where we can start making an analogy with physics. Imagine our events are laid out in spacetime. The events on the left are “timelike separated” from each other, because they are constrained to follow one after another, and so must in effect “happen at different times”. But what about the event on the right? We can think of this as being “spacelike separated” from the others, and happening at a “different place in space” asynchronously from the others. </p>
<p>As a quintessential example of a timelike chain of events, consider making the definition</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723causal2Aimg7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img8.png' alt='' title='' width='102' height='14'> </div>
</p></div>
<p>and then generating the causal graph for the events associated with evaluating <tt>f[f[f[1]]]</tt> (i.e. <tt><a href="http://reference.wolfram.com/language/ref/Nest.html">Nest</a>[f, 1, 3]</tt>): </p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img9_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img9.png' alt='' title='' width='70' height='302'> </div>
</p></div>
<p>A straightforward way to get spacelike events is just to “build in space” by giving an expression like <tt>f[1]</tt> <tt>+</tt> <tt>f[1]</tt> <tt>+</tt> <tt>f[1]</tt> that has parts that can effectively be thought of as being explicitly “laid out in different places”, like the cells in a <a href="https://www.wolframscience.com/nks/chap-2--the-crucial-experiment#sect-2-1--how-do-simple-programs-behave">cellular automaton</a>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img10_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img10.png' alt='' title='' width='359' height='163'> </div>
</p></div>
<p>But one of the major lessons of our Physics Project is that it’s possible for space to “emerge dynamically” from the evolution of a system (in that case, by successive rewriting of hypergraphs). And it turns out very much the same kind of thing can happen in expression evaluation, notably with recursively defined functions. </p>
<p>As a simple example, consider the standard definition of Fibonacci numbers:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723causal2Aimg10_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img12.png' alt='' title='' width='326' height='14'> </div>
</p></div>
<p>With this definition, the causal graph for the evaluation of <tt>f[3]</tt> is then:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img13_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img13.png' alt='' title='' width='433' height='328'> </div>
</p></div>
<p>For <tt>f[5]</tt>, dropping the “context” of each event, and showing only what changed, the graph is</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img14.png' alt='' title='' width='540' height='536'> </div>
</p></div>
<p>while for <tt>f[8]</tt> the structure of the graph is:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img15.png' alt='' title='' width='482' height='482'> </div>
</p></div>
<p>So what is the significance of there being spacelike-separated parts in this graph? At a practical level, a consequence is that those parts correspond to subevaluations that can be done independently, for example in parallel. All the events (or subevaluations) in any timelike chain must be done in sequence. But spacelike-separated events (or subevaluations) don’t immediately have a particular relative order. The whole graph can be thought of as defining a partial ordering for all events—with the events forming a partially ordered set (poset). Our “timelike chains” then correspond to what are usually called chains in the poset. The antichains of the poset represent possible collections of events that can occur “simultaneously”.</p>
<p>And now there’s a deep analogy to physics. Because just like in the standard relativistic approach to spacetime, we can define a sequence of “spacelike surfaces” (or hypersurfaces in 3 + 1-dimensional spacetime) that correspond to possible successive “simultaneity surfaces” where events can consistently be done simultaneously. Put another way, <a href="https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#deriving-special-relativity">any &#8220;foliation&#8221; of the causal graph</a> defines a sequence of “time steps” in which particular collections of events occur—as in for example:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img16_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img16.png' alt='' title='' width='661' height='204'> </div>
</p></div>
<p>And just like in relativity theory, different foliations correspond to different choices of reference frames, or what amount to different choices of “space and time coordinates”. But at least in the examples we’ve seen so far, the “final result” from the evaluation is always the same, regardless of the foliation (or reference frame) we use—just as we expect when there is relativistic invariance.</p>
<p>As a slightly more complex—but ultimately very similar—example, consider the <a href="https://www.wolframscience.com/nks/p130--recursive-sequences/">nestedly recursive function</a>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723causal2Aimg15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img18.png' alt='' title='' width='256' height='38'> </div>
</p></div>
<p>Now the causal graph for <tt>f[12]</tt> has the form</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img19_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523causal2img19.png' alt='' title='' width='353' height='353'> </div>
</p></div>
<p>which again has both spacelike and timelike structure.</p>
<h2 id="foliations-and-the-definition-of-time">Foliations and the Definition of Time</h2>
<p>Let’s go back to our first example above—the evaluation of (1 + (2 + 2)) + (3 + 4). As we saw above, the causal graph in this case is:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img1.png' alt='' title='' width='214' height='169'> </div>
</p></div>
<p>The standard Wolfram Language evaluator makes these events occur in the following order:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img2_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img2.png' alt='' title='' width='212' height='167'> </div>
</p></div>
<p>And by applying events in this order starting with the initial state, we can reconstruct the sequence of states that will be reached at each step by this particular evaluation process (where now we’ve highlighted in each state the part that’s going to be transformed at each step):</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img3.png' alt='' title='' width='112' height='274'> </div>
</p></div>
<p>Here’s the standard evaluation order for the Fibonacci number <tt>f[3]</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img4_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img4.png' alt='' title='' width='293' height='257'> </div>
</p></div>
<p>And here’s the sequence of states generated from this sequence of events:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img5_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img5.png' alt='' title='' width='158' height='289'> </div>
</p></div>
<p>Any valid evaluation order has to eventually visit (i.e. apply) all the events in the causal graph. Here’s the path that’s traced out by the standard evaluation order on the causal graph for <tt>f[8]</tt>. As we’ll discuss later, this corresponds to a depth-first scan of the (directed) graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img6.png' alt='' title='' width='346' height='345'> </div>
</p></div>
<p>But let’s return now to our first example. We’ve seen the order of events used in the standard Wolfram Language evaluation process. But there are actually three different orders that are consistent with the causal relations defined by the causal graph (in the language of posets, each of these is a “total ordering”):</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img7.png' alt='' title='' width='573' height='136'> </div>
</p></div>
<p>And for each of these orders we can reconstruct the sequence of states that would be generated:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img8_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img8.png' alt='' title='' width='444' height='125'> </div>
</p></div>
<p>Up to this point we’ve always assumed that we’re just applying one event at a time. But whenever we have spacelike-separated events, we can treat such events as “simultaneous”—and applied at the same point. And—just like in relativity theory—there are typically multiple possible choices of “simultaneity surfaces”. Each one corresponds to a certain foliation of our causal graph. And in the simple case we’re looking at here, there are only two possible (maximal) foliations:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img9_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img9.png' alt='' title='' width='455' height='172'> </div>
</p></div>
<p>From such foliations we can reconstruct possible total orderings of individual events just by enumerating possible permutations of events within each slice of the foliation (i.e. within each simultaneity surface). But we only really need a total ordering of events if we’re going to apply one event at a time. Yet the whole point is that we can view spacelike-separated events as being “simultaneous”. Or, in other words, we can view our system as “evolving in time”, with each “time step” corresponding to a successive slice in the foliation.</p>
<p>And with this setup, we can reconstruct states that exist at each time step—interspersed by updates that may involve several “simultaneous” (spacelike-separated) events. In the case of the two foliations above, the resulting sequences of (“reconstructed”) states and updates are respectively:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img10_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img10.png' alt='' title='' width='255' height='220'> </div>
</p></div>
<p>As a more complicated example, consider recursively evaluating the Fibonacci number <tt>f[3]</tt> as above. Now the possible (maximal) foliations are:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img11.png' alt='' title='' width='652' height='504'> </div>
</p></div>
<p>For each of these foliations we can then reconstruct an explicit “time series” of states, interspersed by “updates” involving varying numbers of events:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img12_copy.txt' data-c2c-type='text/html'> <a class="magnific image" alt="" title="" href="https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img12-2x.png"><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img12.png' alt='Click to enlarge' title='Click to enlarge' width='603' height='449'></a> </div>
</p></div>
<p>So where in all these is the standard evaluation order? Well, it’s not explicitly here—because it involves doing a single event at a time, while all the foliations here are &#8220;maximal&#8221; in the sense that they aggregate as many events as they can into each spacelike slice. But if we don’t impose this maximality constraint, are there foliations that in a sense “cover” the standard evaluation order? Without the maximality constraint, there turn out in the example we’re using to be not 10 but 1249 possible foliations. And there are 4 that “cover” the standard (“depth-first”) evaluation order (indicated by a dashed red line):</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img13_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img13.png' alt='' title='' width='471' height='404'> </div>
</p></div>
<p>(Only the last foliation here, in which every “slice” is just a single event, can strictly reproduce the standard evaluation order, but the others are all still “consistent with it”.)</p>
<p>In the standard evaluation process, only a single event is ever done at a time. But what if instead one tries to do as many events as possible at a time? Well, that’s what our “maximal foliations” above are about. But one particularly notable case is what corresponds to a breadth-first scan of the causal graph. And this turns out to be covered by the very last maximal foliation we showed above. </p>
<p>How this works may not be immediately obvious from the picture. With our standard layout for the causal graph, the path corresponding to the breadth-first scan is:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img14.png' alt='' title='' width='310' height='274'> </div>
</p></div>
<p>But if we lay out the causal graph differently, the path takes on the much-more-obviously-breadth-first form:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img15.png' alt='' title='' width='268' height='264'> </div>
</p></div>
<p>And now using this layout for the various configurations of foliations above we get:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img16_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img16.png' alt='' title='' width='625' height='460'> </div>
</p></div>
<p>We can think of different layouts for the causal graph as defining different “coordinatizations of spacetime”. If the vertical direction is taken to be time, and the horizontal direction space, then different layouts in effect place events at different positions in time and space. And with the layout here, the last foliation above is “flat”, in the sense that successive slices of the foliation can be thought of as directly corresponding to successive “steps in time”. </p>
<p>In physics terms, different foliations correspond to different “reference frames”. And the “flat” foliation can be thought of as being like the cosmological rest frame, in which the observer is “at rest with respect to the universe”. In terms of states and events, we can also interpret this another way: we can say it’s the foliation in which in some sense the “largest possible number of events are being packed in at each step”. Or, more precisely, if at each step we scan from left to right, we’re doing every successive event that doesn’t overlap with events we’ve already done at this step:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img17_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img17.png' alt='' title='' width='138' height='335'> </div>
</p></div>
<p>And actually this also corresponds to what happens if, instead of using the built-in standard evaluator, we explicitly tell the Wolfram Language to <a href="https://reference.wolfram.com/language/ref/ReplaceAll.html">repeatedly do replacements in expressions</a>. To compare with what we’ve done above, we have to be a little careful in our definitions, using ⊕ and ⊖ as versions of + and – that have to get explicitly evaluated by other rules. But having done this, we get exactly the same sequence of “intermediate expressions” as in the flat (i.e. “breadth-first”) foliation above:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623codeupdateimg7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523foliations3img18.png' alt='' title='' width='491' height='281'> </div>
</p></div>
<p>In general, different foliations can be thought of as specifying different “event-selection functions” to be applied to determine what events should occur at the next steps from any given state. At one extreme we can pick single-event-at-a-time event selection functions—and at the other extreme we can pick maximum-events-at-a-time event selection functions. In our Physics Project we have called the states obtained by applying maximal collections of events at a time “<a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/generational-evolution/#p-294" target="_blank" rel="noopener">generational states</a>”. And in effect these states represent the typical way we parse physical “spacetime”—in which we take in “all of space” at every successive moment of time. At a practical level the reason we do this is that the speed of light is somehow fast compared to the operation of our brains: if we look at our local surroundings (say the few hundred meters around us), light from these will reach us in a microsecond, while it takes our brains milliseconds to register what we’re seeing. And this makes it reasonable for us to think of there being an “instantaneous state of space” that we can perceive “all at once” at each particular “moment in time”.</p>
<p>But what’s the analog of this when it comes to expression evaluation? We’ll discuss this a little more later. But suffice it to say here that it depends on who or what the “observer” of the process of evaluation is supposed to be. If we’ve got different elements of our states laid out explicitly in arrays, say in a GPU, then we might again “perceive all of space at once”. But if, for example, the data associated with states is connected through chains of pointers in memory or the like, and we “observe” this data only when we explicitly follow these pointers, then our perception won’t as obviously involve something we can think of as &#8220;bulk space&#8221;. But by thinking in terms of foliations (or reference frames) as we have here, we can potentially fit what’s going on into something like space, that seems familiar to us. Or, put another way, we can imagine in effect “programming in a certain reference frame” in which we can aggregate multiple elements of what’s going on into something we can consider as an analog of space—thereby making it familiar enough for us to understand and reason about.</p>
<h2 id="multiway-evaluation-and-multiway-graphs">Multiway Evaluation and Multiway Graphs</h2>
<p>We can view everything we’ve done so far as dissecting and reorganizing the standard evaluation process. But let’s say we’re just given certain underlying rules for transforming expressions—and then we apply them in all possible ways. It’ll give us a <a href="https://www.wolframscience.com/nks/chap-5--two-dimensions-and-beyond#sect-5-6--multiway-systems">&#8220;multiway&#8221; generalization of evaluation</a>—in which instead of there being just one path of history, there are many. And in our Physics Project, this is exactly how the <a href="https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#the-inevitability-of-quantum-mechanics">transition from classical to quantum physics works</a>. And as we proceed here, we’ll see a close correspondence between multiway evaluation and quantum processes.</p>
<p>But let’s start again with our expression (1 + (2 + 2)) + (3 + 4), and consider all possible ways that individual integer addition “events” can be applied to evaluate this expression. In this particular case, the result is pretty simple, and can be represented by a tree that branches in just two places:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img1.png' alt='' title='' width='372' height='295'> </div>
</p></div>
<p>But one thing to notice here is that even at the first step there’s an event <img style="margin-bottom: -7px" loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img4.png' alt='' title='' width='97' height='27'/> that we’ve never seen before. It’s something that’s possible if we apply integer addition in all possible places. But when we start from the standard evaluation process, the basic event <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img5.png' width= '65' height='12' align='absmiddle'></span> just never appears with the “expression context” we’re seeing it in here. </p>
<p>Each branch in the tree above in some sense represents a different “path of history”. But there’s a certain redundancy in having all these separate paths<span style="font-size:12px">—</span>because there are multiple instances of the same expression that appear in different places. And if we treat these as equivalent and merge them we now get:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img6.png' alt='' title='' width='348' height='264'> </div>
</p></div>
<p>(The question of “state equivalence” is a subtle one, that ultimately depends on the operation of the observer, and how the observer constructs their perception of what’s going on. But for our purposes here, we’ll treat expressions as equivalent if they are structurally the same, i.e. every instance of <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img7.png' width= '8' height='8' align='absmiddle'></span> or of 5 is “the same” <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img8.png' width= '8' height='8' align='absmiddle'></span> or 5.)</p>
<p>If we now look only at states (i.e. expressions) we’ll get a multiway graph, of the kind that’s appeared in our Physics Project and in many applications of concepts from it:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img9_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img9.png' alt='' title='' width='235' height='249'> </div>
</p></div>
<p>This graph in a sense gives a succinct summary of possible paths of history, which here correspond to possible evaluation paths. The standard evaluation process corresponds to a particular path in this multiway graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img2_copy.txt' data-c2c-type='text/html'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img10.png' alt='' title='' width='244' height='261'> </div>
</p></div>
<p>What about a more complicated case? For example, what is the multiway graph for our recursive computation of Fibonacci numbers? As we’ll discuss at more length below, in order to make sure every branch of our recursive evaluation terminates, we have to give a slightly more careful definition of our function <tt>f</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723multiway4Aimg11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img12.png' alt='' title='' width='433' height='14'> </div>
</p></div>
<p>But now here’s the multiway tree for the evaluation of <tt>f[2]</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img13_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img13.png' alt='' title='' width='526' height='298'> </div>
</p></div>
<p>And here’s the corresponding multiway graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img14.png' alt='' title='' width='272' height='307'> </div>
</p></div>
<p>The leftmost branch in the multiway tree corresponds to the standard evaluation process; here’s the corresponding path in the multiway graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img15.png' alt='' title='' width='284' height='305'> </div>
</p></div>
<p>Here’s the structure of the multiway graph for the evaluation of <tt>f[3]</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923multiwayupdateimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092923multiwayupdateimg1.png' alt='' title='' width='670' height='429'> </div>
</p></div>
<p>Note that (as we’ll discuss more later) all the possible evaluation paths in this case lead to the same final expression, and in fact in this particular example all the paths are of the same length (12 steps, i.e. 12 evaluation events). </p>
<p>In the multiway graphs we’re drawing here, every edge in effect corresponds to an evaluation event. And we can imagine setting up foliations in the multiway graph that divide these events into slices. But what is the significance of these slices? When we did the same kind of thing above for causal graphs, we could interpret the slices as representing “instantaneous states laid out in space”. And by analogy we can interpret a slice in the multiway graph as representing “instantaneous states laid out across branches of history”. In the context of our Physics Project, we can then think of these slices as being like superpositions in quantum mechanics, or states “laid out in branchial space”. And, as we’ll discuss later, just as we can think of elements laid out in “space” as corresponding in the Wolfram Language to parts in a symbolic expression (like a list, a sum, etc.), so now we’re dealing with a new kind of way of aggregating states across branchial space, that has to be represented with new language constructs.</p>
<p>But let’s return to the very simple case of (1 + (2 + 2)) + (3 + 4). Here’s a more complete representation of the multiway evaluation process in this case, including both all the events involved, and the causal relations between them:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img17_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img17.png' alt='' title='' width='346' height='358'> </div>
</p></div>
<p>The “single-way” evaluation process we discussed above uses only part of this:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img4_copy.txt' data-c2c-type='text/html'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img18.png' alt='' title='' width='346' height='358'> </div>
</p></div>
<p>And from this part we can pull out the causal relations between events to reproduce the (“single-way”) causal graph we had before. But what if we pull out all the causal relations in our full graph?</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img19_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523multiway4img19.png' alt='' title='' width='261' height='258'> </div>
</p></div>
<p>What we then have is the <a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/the-relationship-between-graphs-and-the-multiway-causal-graph/" target="_blank" rel="noopener">multiway causal graph</a>. And from foliations of this, we can construct possible histories—though now they’re multiway histories, with the states at particular time steps now being what amount to superposition states. </p>
<p>In the particular case we’re showing here, the multiway causal graph has a very simple structure, consisting essentially just of a bunch of isomorphic pieces. And as we’ll see later, this is an inevitable consequence of the nature of the evaluation we’re doing here, and its property of <a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/the-phenomenon-of-causal-invariance/" target="_blank" rel="noopener">causal invariance</a> (and in this case, confluence).</p>
<h2 id="branchlike-separation">Branchlike Separation</h2>
<p>Although what we’ve discussed has already been somewhat complicated, there’s actually been a crucial simplifying assumption in everything we’ve done. We’ve assumed that different transformations on a given expression can never apply to the same part of the expression. Different transformations can apply to different parts of the same expression (corresponding to spacelike-separated evaluation events). But there’s never been a “conflict” between transformations, where multiple transformations can apply to the same part of the same expression. </p>
<p>So what happens if we relax this assumption? In effect it means that we can generate different “incompatible” branches of history—and we can characterize the events that produce this as “branchlike separated”. And when such branchlike-separated events are applied to a given state, they’ll produce multiple states which we can characterize as “separated in <a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/foliations-of-the-multiway-graph-and-the-structure-of-branchial-space/" target="_blank" rel="noopener">branchial space</a>”, but nevertheless correlated as a result of their “common ancestry”—or, in quantum mechanics terms, “entangled”.</p>
<p>As a very simple first example, consider the rather trivial function <tt>f</tt> defined by</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723branchlike5Aimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img2.png' alt='' title='' width='77' height='14'> </div>
</p></div>
<p>If we evaluate <tt>f[f[0]]</tt> (for any <tt>f</tt>) there are immediately two “conflicting” branches: one associated with evaluation of the “outer <tt>f</tt>”, and one with evaluation of the “inner <tt>f</tt>”:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img3.png' alt='' title='' width='170' height='253'> </div>
</p></div>
<p>We can indicate branchlike-separated pairs of events by a dashed line:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img4_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img4.png' alt='' title='' width='113' height='264'> </div>
</p></div>
<p>Adding in causal edges, and merging equivalent states, we get:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img5_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img5.png' alt='' title='' width='155' height='337'> </div>
</p></div>
<p>We see that some events are causally related. The first two events are not—but given that they involve overlapping transformations they are “branchially related” (or, in effect, entangled). </p>
<p>Evaluating the expression <tt>f[f[0]+1]</tt> gives a more complicated graph, with two different instances of branchlike-separated events:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img6.png' alt='' title='' width='230' height='429'> </div>
</p></div>
<p>Extracting the multiway states graph we get</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img7.png' alt='' title='' width='153' height='213'> </div>
</p></div>
<p>where now we have indicated “branchially connected” states by pink “branchial edges”. Pulling out only these branchial edges then gives the (rather trivial) branchial graph for this evaluation process:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img8_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img8.png' alt='' title='' width='138' height='96'> </div>
</p></div>
<p>There are many subtle things going on here, particularly related to the treelike structure of expressions. We’ve talked about separations between events: timelike, spacelike and branchlike. But what about separations between elements of an expression? In something like <tt>{f[0]</tt>, <tt>f[0]</tt>, <tt>f[0]}</tt> it’s reasonable to extend our characterization of separations between events, and say that the <tt>f[0]</tt>&#8217;s in the expression can themselves be considered spacelike separated. But what about in something like <tt>f[f[0]]</tt>? We can say that the <tt>f[_]</tt>&#8217;s here “overlap”—and “conflict” when they are transformed—making them branchlike separated. But the structure of the expression also inevitably makes them “<a href="https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/#causal-graphs-and-the-physicalization-of-combinators">treelike separated</a>”. We’ll see later how to think about the relation between treelike-separated elements in more fundamental terms, ultimately using hypergraphs. But for now an obvious question is what in general the relation between branchlike-separated elements can be.</p>
<p>And essentially the answer is that branchlike separation has to “come with” some other form of separation: spacelike, treelike, rulelike, etc. Rulelike separation involves having multiple rules for the same object (e.g. a rule <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img9.png' width= '37' height='9' align='absmiddle'></span> as well as <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img10.png' width= '39' height='9' align='absmiddle'></span>)—and we’ll talk about this <a href="https://writings.stephenwolfram.com/2023/09/expression-evaluation-and-fundamental-physics/#the-rulial-case">later</a>. With spacelike separation, we basically get branchlike separation when subexpressions “overlap”. This is fairly subtle for tree-structured expressions, but is much more straightforward for strings, and indeed we have <a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/" target="_blank" rel="noopener">discussed this case extensively</a> in connection with our Physics Project.</p>
<p>Consider the (rather trivial) string rewriting rule:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img11.png' alt='' title='' width='51' height='10'> </div>
</p></div>
<p>Applying this rule to AAAAAA we get:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img12_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img12.png' alt='' title='' width='590' height='482'> </div>
</p></div>
<p>Some of the events here are purely spacelike separated, but whenever the characters they involve overlap, they are also branchlike separated (as indicated by the dashed pink lines). Extracting the multiway states graph we get:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img13_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img13.png' alt='' title='' width='346' height='322'> </div>
</p></div>
<p>And now we get the following branchial graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723codeupdateAimg4_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723codeupdateAimg4.png' alt='' title='' width='359' height='172'> </div>
</p></div>
<p>So how can we see analogs in expression evaluation? It turns out that <a href="https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/">combinators provide a good example</a> (and, yes, it’s quite remarkable that we’re using combinators here to help explain something—given that combinators <a href="https://writings.stephenwolfram.com/2020/12/combinators-and-the-story-of-computation/">almost always seem like the most obscure</a> and difficult-to-explain things around). Define the standard S and K combinators:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723branchlike5Aimg14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img16.png' alt='' title='' width='247' height='14'> </div>
</p></div>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img17_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img17.png' alt='' title='' width='120' height='14'> </div>
</p></div>
<p>Now we have for example</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img18_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img18.png' alt='' title='' width='417' height='370'> </div>
</p></div>
<p>where there are many spacelike-separated events, and a single pair of branchlike + treelike-separated ones. With a slightly more complicated initial expression, we get the rather messy result</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img19.png' alt='' title='' width='613' height='458'> </div>
</p></div>
<p>now with many branchlike-separated states:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img8_copy.txt' data-c2c-type='text/html'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img20.png' alt='' title='' width='501' height='315'> </div>
</p></div>
<p>Rather than using the full standard S, K combinators, we can consider a <a href="https://www.wolframscience.com/nks/chap-3--the-world-of-simple-programs#sect-3-10--symbolic-systems">simpler combinator definition</a>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723branchlike5Aimg19_copy.txt' data-c2c-type='text/html'>  <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img21.png' alt='' title='' width='175' height='14'> </div>
</p></div>
<p>Now we have for example</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img22_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img22.png' alt='' title='' width='238' height='318'> </div>
</p></div>
<p>where the branchial graph is</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img23_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img23.png' alt='' title='' width='403' height='188'> </div>
</p></div>
<p>and the multiway causal graph is:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img24_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img24.png' alt='' title='' width='512' height='521'> </div>
</p></div>
<p>The expression <tt>f[f[f][f]][f]</tt> gives a more complicated multiway graph</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img25_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img25.png' alt='' title='' width='296' height='280'> </div>
</p></div>
<p>and branchial graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img26_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092523branchlike5img26.png' alt='' title='' width='142' height='224'> </div>
</p></div>
<h2 id="interpretations-analogies-and-the-concept-of-multi">Interpretations, Analogies and the Concept of Multi</h2>
<p>Before we started talking about branchlike separation, the only kinds of separation we considered were timelike and spacelike. And in this case we were able to take the causal graphs we got, and set up foliations of them where each slice could be thought of as representing a sequential step in time. In effect, what we were doing was to aggregate things so that we could talk about what happens in “all of space” at a particular time.</p>
<p>But when there’s branchlike separation we can no longer do this. Because now there isn’t a single, consistent “configuration of all of space” that can be thought of as evolving in a single thread through time. Rather, there are “multiple threads of history” that wind their way through the branchings (and mergings) that occur in the multiway graph. One can make foliations in the multiway graph—much like one does in the causal graph. (More strictly, one really needs to make the foliations in the multiway causal graph—but these can be “inherited” by the multiway graph.)</p>
<p>In physics terms, the (single-way) causal graph can be thought of as a discrete version of ordinary spacetime—with a foliation of it specifying a “reference frame” that leads to a particular identification of what one considers space, and what time. But what about the multiway causal graph? In effect, we can imagine that it defines a new, branchial “direction”, in addition to the spatial direction. Projecting in this branchial direction, we can then think of getting a kind of branchial analog of spacetime that we can call branchtime. And when we construct the multiway graph, we can basically imagine that it’s a representation of branchtime.</p>
<p>A particular slice of a foliation of the (single-way) causal graph can be thought of as corresponding to an “instantaneous state of (ordinary) space”. So what does a slice in a foliation of the multiway graph represent? It’s effectively a branchial or multiway combination of states—a collection of states that can somehow all exist “at the same time”. And in physics terms we can interpret it as a quantum superposition of states. </p>
<p>But how does all this work in the context of expressions? The parts of a single expression like <nobr><em>a</em> <tt>+</tt> <em>b</em> <tt>+</tt> <em>c</em> <tt>+</tt> <em>d</em></nobr> or <tt>{</tt><em>a</em><tt>,</tt> <em>b</em><tt>,</tt> <em>c</em><tt>,</tt> <em>d</em><tt>}</tt> can be thought of being spacelike separated, or in effect “laid out in space”. But what kind of a thing has parts that are “laid out in branchial space”? It’s a new kind of fundamentally multiway construct. We’re not going to explore it too much here, but in the Wolfram Language we might in future call it <tt>Multi</tt>. And just as <tt>{</tt><em>a</em><tt>,</tt> <em>b</em><tt>,</tt> <em>c</em><tt>,</tt> <em>d</em><tt>}</tt> (or <tt><a href="http://reference.wolfram.com/language/ref/List.html">List</a></tt><tt>[</tt><em>a</em><tt>,</tt> <em>b</em><tt>,</tt> <em>c</em><tt>,</tt> <em>d</em><tt>]</tt>) can be thought of as representing <em>a</em>, <em>b</em>, <em>c</em>, <em>d</em> “laid out in space”, so now <tt>Multi</tt><tt>[</tt><em>a</em><tt>,</tt> <em>b</em><tt>,</tt> <em>c</em><tt>,</tt> <em>d</em><tt>]</tt> would represent <nobr><em>a</em>, <em>b</em>, <em>c</em>, <em>d</em></nobr> “laid out branchial space”.</p>
<p>In ordinary evaluation, we just generate a specific sequence of individual expressions. But in multiway evaluation, we can imagine that we generate a sequence of <tt>Multi</tt> objects. In the examples we’ve seen so far, we always eventually get a <tt>Multi</tt> containing just a single expression. But we’ll soon find out that that’s not always how things work, and we can perfectly well end up with a <tt>Multi</tt> containing multiple expressions.</p>
<p>So what might we do with a <tt>Multi</tt>? In a typical “nondeterministic computation” we probably want to ask: “Does the <tt>Multi</tt> contain some particular expression or pattern that we’re looking for?” If we imagine that we’re doing a “probabilistic computation” we might want to ask about the frequencies of different kinds of expressions in the <tt>Multi</tt>. And if we&#8217;re doing quantum computation with the normal formalism of quantum mechanics, we might want to tag the elements of the <tt>Multi</tt> with “quantum amplitudes” (that, yes, in our model presumably have magnitudes determined by path counting in the multiway graph, and phases representing the “positions of elements in branchial space”). And in a traditional quantum measurement, the concept would typically be to determine a projection of a <tt>Multi</tt>, or in effect an inner product of <tt>Multi</tt> objects. (And, yes, if one knows only that projection, it’s not going to be enough to let one unambiguously continue the “multiway computation”; the quantum state has in effect been “collapsed”.)</p>
<h2 id="is-there-always-a-definite-result">Is There Always a Definite Result?</h2>
<p>For an expression like (1 + (2 + 2)) + (3 + 4) it doesn’t matter in what order one evaluates things; one always gets the same result—so that the corresponding multiway graph leads to just a single final state:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img1.png' alt='' title='' width='204' height='209'> </div>
</p></div>
<p>But it’s not always true that there’s a single final state. For example, with the definitions</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723result7Aimg2_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723result7Aimg2.png' alt='' title='' width='104' height='14'> </div>
</p></div>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723result7Aimg3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723result7Aimg3.png' alt='' title='' width='102' height='14'> </div>
</p></div>
<p>standard evaluation in the Wolfram Language gives the result 0 for <tt>f[f[0]]</tt> but the full multiway graph shows that (with a different evaluation order) it’s possible instead to get the result <tt style="font-weight: 600;">g[g[0]]</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img5_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img5.png' alt='' title='' width='315' height='146'> </div>
</p></div>
<p>And in general when a certain collection of rules (or definitions) always leads to just a single result, one says that the collection of rules is confluent; otherwise it’s not. Pure arithmetic turns out to be confluent. But there are <a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-for-string-substitution-systems/testing-for-causal-invariance/" target="_blank" rel="noopener">plenty of examples (e.g. in string rewriting)</a> that are not. Ultimately a failure of confluence must come from the presence of branchlike separation—or in effect a conflict between behavior on two different branches. And so in the example above we see that there are branchlike-separated “conflicting” events that never resolve—yielding two different final outcomes: </p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img6.png' alt='' title='' width='213' height='277'> </div>
</p></div>
<p>As an even simpler example, consider the definitions <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img7.png' width= '34' height='9' align='absmiddle'></span> and <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img8.png' width= '36' height='9' align='absmiddle'></span>. In the Wolfram Language these definitions immediately overwrite each other. But assume they could both be applied (say through explicit <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img9.png' width= '37' height='9' align='absmiddle'></span>, <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img10.png' width= '39' height='9' align='absmiddle'></span> rules). Then there’s a multiway graph with two “unresolved” branches—and two outcomes:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img11.png' alt='' title='' width='161' height='117'> </div>
</p></div>
<p>For string rewriting systems, it’s easy to enumerate possible rules. The rule </p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img12_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img12.png' alt='' title='' width='66' height='13'> </div>
</p></div>
<p>(that effectively sorts the elements in the string) is confluent:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img13_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img13.png' alt='' title='' width='197' height='272'> </div>
</p></div>
<p>But the rule</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img14.png' alt='' title='' width='125' height='13'> </div>
</p></div>
<p>is not confluent</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img15.png' alt='' title='' width='501' height='247'> </div>
</p></div>
<p>and “evaluates” BABABA to four distinct outcomes:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img16_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img16.png' alt='' title='' width='238' height='13'> </div>
</p></div>
<p>These are all cases where “internal conflicts” lead to multiple different final results. But another way to get different results is through “side effects”. Consider first setting <em>x</em> = 0 then evaluating <tt>{x = 1, x + 1}</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623result7img17_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img17.png' alt='' title='' width='582' height='405'> </div>
</p></div>
<p>If the order of evaluation is such that <tt>x + 1</tt> is evaluated before <tt>x = 1</tt> it will give <tt>1</tt>, otherwise it will give <tt>2</tt>, leading to the two different outcomes <tt>{1, 1}</tt> and <tt>{1, 2}</tt>. In some ways this is like the example above where we had two distinct rules: <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img18.png' width= '37' height='9' align='absmiddle'></span> and <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623result7img19.png' width= '39' height='9' align='absmiddle'></span>. But there’s a difference. While explicit rules are essentially applied only “instantaneously”, an assignment like <em>x</em> = 1 has a “permanent” effect, at least until it is “overwritten” by another assignment. In an evaluation graph like the one above we’re showing particular expressions generated during the evaluation process. But when there are assignments, there’s an additional “hidden state” that in the Wolfram Language one can think of as corresponding to the state of the global symbol table. If we included this, then we’d again see rules that apply “instantaneously”, and we’d be able to explicitly trace causal dependencies between events. But if we elide it, then we effectively hide the causal dependence that’s “carried” by the state of the symbol table, and the evaluation graphs we’ve been drawing are necessarily somewhat incomplete.</p>
<h2 id="computations-that-never-end">Computations That Never End</h2>
<p>The basic operation of the Wolfram Language evaluator is to keep doing transformations until the result no longer changes (or, in other words, until a fixed point is reached). And that’s convenient for being able to “get a definite answer”. But it’s rather different from what one usually imagines happens in physics. Because in that case we’re typically dealing with things that just “keep progressing through time”, without ever getting to any fixed point. (<a href="https://www.wolframphysics.org/bulletins/2020/05/event-horizons-singularities-and-other-exotic-spacetime-phenomena/" target="_blank" rel="noopener">&#8220;Spacetime singularities&#8221;</a>, say in black holes, do for example involve reaching fixed points where “time has come to an end”.) </p>
<p>But what happens in the Wolfram Language if we just type <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img1.png' width= '60' height='9' align='absmiddle'></span>, without giving any value to <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img2.png' width= '8' height='8' align='absmiddle'></span>? The Wolfram Language evaluator will keep evaluating this, trying to reach a fixed point. But it’ll never get there. And in practice it’ll give a message, and (at least in <a href="https://reference.wolfram.com/language/guide/SummaryOfNewFeaturesIn133">Version 13.3</a> and above) return a <tt><a href="http://reference.wolfram.com/language/ref/TerminatedEvaluation.html">TerminatedEvaluation</a></tt> object:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img3.png' alt='' title='' width='342' height='72'> </div>
</p></div>
<p>What’s going on inside here? If we look at the evaluation graph, we can see that it involves an infinite chain of evaluation events, that progressively “extrude” <tt>+1</tt>’s:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img4_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img4.png' alt='' title='' width='147' height='290'> </div>
</p></div>
<p>A slightly simpler case (that doesn’t raise questions about the evaluation of <tt><a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt>) is to consider the definition</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg5_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img6.png' alt='' title='' width='127' height='14'> </div>
</p></div>
<p>which has the effect of generating an infinite chain of progressively more “<tt>f</tt>-nested” expressions:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img7.png' alt='' title='' width='130' height='197'> </div>
</p></div>
<p>Let’s say we define two functions:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg7.png' alt='' title='' width='130' height='14'> </div>
</p></div>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg8_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg8.png' alt='' title='' width='133' height='14'> </div>
</p></div>
<p>Now we don’t just get a simple chain of results; instead we get an exponentially growing multiway graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img11.png' alt='' title='' width='364' height='224'> </div>
</p></div>
<p>In general, whenever we have a recursive definition (say of <tt>f</tt> in terms of <tt>f</tt> or <em>x</em> in terms of <em>x</em>) there’s the possibility of an infinite process of evaluation, with no “final fixed point”. There are of course specific cases of recursive definitions that always terminate—like the Fibonacci example we gave above. And indeed when we’re dealing with so-called “<a href="https://www.wolframscience.com/nks/notes-4-3--primitive-recursive-functions/">primitive recursion</a>” this is how things inevitably work: we’re always “systematically counting down” to some defined base case (say <nobr><tt>f[1] = 1</tt>).</nobr></p>
<p>When we look at string rewriting (or, for that matter, hypergraph rewriting), evolution that doesn’t terminate is quite ubiquitous. And in direct analogy with, for example, the string rewriting rule A<img style="margin-bottom: -1px" class='' src="https://content.wolfram.com/sites/32/2022/10/rightarrow2.png" width='15' height='11' >BBB, BB<img style="margin-bottom: -1px" class='' src="https://content.wolfram.com/sites/32/2022/10/rightarrow2.png" width='15' height='11' >A we can set up the definitions</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg10_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg10.png' alt='' title='' width='261' height='14'> </div>
</p></div>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg11.png' alt='' title='' width='243' height='14'> </div>
</p></div>
<p>and then the (infinite) multiway graph begins:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img15.png' alt='' title='' width='274' height='340'> </div>
</p></div>
<p>One might think that the possibility of evaluation processes that don’t terminate would be a fundamental problem for a system set up like the Wolfram Language. But it turns out that in current normal usage one basically never runs into the issue except by mistake, when there’s a bug in one’s program. </p>
<p>Still, if one explicitly wants to generate an infinite evaluation structure, it’s not hard to do so. Beyond <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img16.png' width= '60' height='9' align='absmiddle'></span> one can define</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img18.png' alt='' title='' width='69' height='13'> </div>
</p></div>
<p>and then one gets the multiway graph</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img19_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img19.png' alt='' title='' width='491' height='220'> </div>
</p></div>
<p>which has <tt><a href="http://reference.wolfram.com/language/ref/CatalanNumber.html">CatalanNumber</a>[t]</tt> (or asymptotically ~4<sup><em>t</em></sup>) states at layer <em>t</em>.</p>
<p>Another “common bug” form of non-terminating evaluation arises when one makes a primitive-recursion-style definition without giving a “boundary condition”. Here, for example, is the Fibonacci recursion without <tt>f[0]</tt> and <tt>f[1]</tt> defined:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg18_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img23.png' alt='' title='' width='254' height='14'> </div>
</p></div>
<p>And in this case the multiway graph is infinite</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img24_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img24.png' alt='' title='' width='620' height='244'> </div>
</p></div>
<p>with ~2<sup><em>t</em></sup> states at layer <em>t</em>.</p>
<p>But consider now the “unterminated factorial recursion”</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg21_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img27.png' alt='' title='' width='188' height='14'> </div>
</p></div>
<p>On its own, this just leads to a single infinite chain of evaluation</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img28_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img28.png' alt='' title='' width='124' height='276'> </div>
</p></div>
<p>but if we add the explicit rule that multiplying anything by zero gives zero (i.e. <tt>0 _ &#8594; 0</tt>) then we get</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img29_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img29.png' alt='' title='' width='321' height='389'> </div>
</p></div>
<p>in which there’s a “zero sink” in addition to an infinite chain of <tt>f[–n]</tt> evaluations.</p>
<p>Some definitions have the property that they provably always terminate, though it may take a while. An example is the combinator definition we made above:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg24_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img31.png' alt='' title='' width='175' height='14'> </div>
</p></div>
<p>Here’s the multiway graph starting with <tt>f[f[f][f]][f]</tt>, and terminating in at most 10 steps:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img32_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img32.png' alt='' title='' width='559' height='358'> </div>
</p></div>
<p>Starting with <tt>f[f[f][f][f][f]][f]</tt> the multiway graph becomes</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img33_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img33.png' alt='' title='' width='346' height='278'> </div>
</p></div>
<p>but again the evaluation always terminates (and gives a unique result). In this case we can see why this happens: at each step <tt>f[x_][y_]</tt> effectively “discards <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img34.png' width= '9' height='11' align='absmiddle'></span>”, thereby “fundamentally getting smaller”, even as it “puffs up” by making three copies of <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img35.png' width= '8' height='8' align='absmiddle'></span>. </p>
<p>But if instead one uses the definition </p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723computations8Aimg29_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img37.png' alt='' title='' width='178' height='14'> </div>
</p></div>
<p>things get more complicated. In some cases, the multiway evaluation always terminates</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img38_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623computations8img38.png' alt='' title='' width='151' height='180'> </div>
</p></div>
<p>while in others, it never terminates:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723codeupdateAimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723codeupdateAimg1.png' alt='' title='' width='613' height='201'> </div>
</p></div>
<p>But then there are cases where there is sometimes termination, and sometimes not:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723codeupdateAimg3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723codeupdateAimg3.png' alt='' title='' width='660' height='219'> </div>
</p></div>
<p>In this particular case, what’s happening is that evaluation of the first argument of the “top-level <tt>f</tt>” never terminates, but if the top-level <tt>f</tt> is evaluated before its arguments then there’s immediate termination. Since the standard Wolfram Language evaluator evaluates arguments first (“leftmost-innermost evaluation”), it therefore won’t terminate in this case—even though there are branches in the multiway evaluation (corresponding to “outermost evaluation”) that do terminate.</p>
<h2 id="transfinite-evaluation">Transfinite Evaluation</h2>
<p>If a computation reaches a fixed point, we can reasonably say that that’s the “result” of the computation. But what if the computation goes on forever? Might there still be some <a href="https://www.wolframscience.com/nks/p788--implications-for-mathematics-and-its-foundations/">&#8220;symbolic&#8221; way to represent what happens</a>—that for example allows one to compare results from different infinite computations? </p>
<p>In the case of ordinary numbers, we know that we can define a “symbolic infinity” ∞ (<tt><a href="http://reference.wolfram.com/language/ref/Infinity.html">Infinity</a></tt> in Wolfram Language) that represents an infinite number and has all the obvious basic arithmetic properties:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img1.png' alt='' title='' width='148' height='69'> </div>
</p></div>
<p>But what about infinite processes, or, more specifically, infinite multiway graphs? Is there some useful symbolic way to represent such things? Yes, they’re all “infinite”. But somehow we’d like to distinguish between infinite graphs of different forms, say:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923transfinite9updateimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092923transfinite9updateimg1.png' alt='' title='' width='300' height='107'> </div>
</p></div>
<p>And already for integers, it’s been known for more than a century that there’s a more detailed way to characterize infinities than just referring to them all as ∞: it’s to use the idea of <a href="https://www.wolframscience.com/nksonline/page-1162b/">transfinite numbers</a>. And in our case we can imagine successively numbering the nodes in a multiway graph, and seeing what the largest number we reach is. For an infinite graph of the form</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img3.png' alt='' title='' width='307' height='5'> </div>
</p></div>
<p>(obtained say from <em>x</em> = <em>x</em> + 1 or <em>x</em> = {<em>x</em>}) we can label the nodes with successive integers, and we can say that the “largest number reached” is the transfinite ordinal ω.</p>
<p>A graph consisting of two infinite chains is then characterized by 2ω, while an infinite 2D grid is characterized by ω<sup>2</sup>, and an infinite binary tree is characterized by 2<sup>ω</sup>. </p>
<p>What about larger numbers? To get to ω<sup>ω</sup> we can use a rule like</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723transfinite9Aimg9_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img10.png' alt='' title='' width='419' height='14'> </div>
</p></div>
<p>that effectively yields a multiway graph that corresponds to a tree in which successive layers have progressively larger numbers of branches:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623transfinite9img11.png' alt='' title='' width='255' height='129'> </div>
</p></div>
<p>One can think of a definition like <em>x</em> = <em>x</em> + 1 as setting up a “self-referential data structure”, whose specification is finite (in this case essentially a loop), and where the infinite evaluation process arises only when one tries to get an explicit value out of the structure. More elaborate recursive definitions can’t, however, readily be thought of as setting up straightforward self-referential data structures. But they still seem able to be characterized by transfinite numbers. </p>
<p>In general many multiway graphs that differ in detail will be associated with a given transfinite number. But the expectation is that transfinite numbers can potentially provide robust characterizations of infinite evaluation processes, with different constructions of the “same evaluation” able to be identified as being associated with the same canonical transfinite number. </p>
<p>Most likely, definitions purely involving pattern matching won’t be able to generate infinite evaluations beyond &#949;<sub>0</sub> = ω<sup>ω<sup>ω<sup>.<sup>.<sup>.</sup></sup></sup></sup></sup>—which is also the limit of where one can reach with proofs based on ordinary induction, Peano Arithmetic, etc. It’s <a href="https://www.wolframscience.com/nks/notes-12-9--examples-of-unprovable-statements/">perfectly possible to go further</a>—but one needs to explicitly use functions like <tt><a href="http://reference.wolfram.com/language/ref/NestWhile.html">NestWhile</a></tt> etc. in the definitions that are given.</p>
<p>And there’s another issue as well: given a particular set of definitions, there’s no limit to how difficult it can be to determine the ultimate multiway graph that’ll be produced. In the end this is a consequence of computational irreducibility, and of the undecidability of the halting problem, etc. And what one can expect in the end is that some infinite evaluation processes one will be able to prove can be characterized by particular transfinite numbers, but others one won’t be able to “tie down” in this way—and in general, as computational irreducibility might suggest, won’t ever allow one to give a “finite symbolic summary”. </p>
<h2 id="the-question-of-the-observer">The Question of the Observer</h2>
<p>One of the key lessons of our Physics Project is the importance of the character of the observer in determining what one “takes away” from a given underlying system. And in setting up the evaluation process—say in the Wolfram Language—the typical objective is to align with the way human observers expect to operate. And so, for example, one normally expects that one will give an expression as input, then in the end get an expression as output. The process of transforming input to output is analogous to the doing of a calculation, the answering of a question, the making of a decision, the forming of a response in human dialog, and potentially the forming of a thought in our minds. In all of these cases, we treat there as being a certain “static” output.</p>
<p>It’s very different from the way physics operates, because in physics “time always goes on”: there’s (essentially) always another step of computation to be done. In our usual description of evaluation, we talk about “reaching a fixed point”. But an alternative would be to say that we reach a state that just repeats unchanged forever—but we as observers equivalence all those repeats, and think of it as having reached a single, unchanging state. </p>
<p>Any modern practical computer also fundamentally works much more like physics: there are always computational operations going on—even though those operations may end up, say, continually putting the exact same pixel in the same place on the screen, so that we can “summarize” what’s going on by saying that we’ve reached a fixed point.</p>
<p>There’s much that can be done with computations that reach fixed points, or, equivalently with functions that return definite values. And in particular it’s straightforward to compose such computations or functions, continually taking output and then feeding it in as input. But there’s a whole world of other possibilities that open up once one can deal with infinite computations. As a practical matter, one can treat such computations “lazily”—representing them as purely symbolic objects from which one can derive particular results if one explicitly asks to do so.</p>
<p>One kind of result might be of the type typical in <a href="https://www.wolframscience.com/metamathematics/relations-to-automated-theorem-proving/">logic programming or automated theorem proving</a>: given a potentially infinite computation, is it ever possible to reach a specified state (and, if so, what is the path to do so)? Another type of result might involve extracting a particular “time slice” (with some choice of foliation), and in general representing the result as a <tt>Multi</tt>. And still another type of result (reminiscent of “probabilistic programming”) might involve not giving an explicit <tt>Multi</tt>, but rather computing certain statistics about it.</p>
<p>And in a sense, each of these different kinds of results can be thought of as what’s extracted by a different kind of observer, who is making different kinds of equivalences. </p>
<p>We have a certain typical experience of the physical world that’s determined by features of us as observers. For example, as we mentioned above, we tend to think of “all of space” progressing “together” through successive moments of time. And the reason we think this is that the regions of space we typically see around us are small enough that the speed of light delivers information on them to us in a time that’s short compared to our “brain processing time”. If we were bigger or faster, then we wouldn’t be able to think of what’s happening in all of space as being “simultaneous” and we’d immediately be thrust into issues of relativity, reference frames, etc. </p>
<p>And in the case of expression evaluation, it’s very much the same kind of thing. If we have an expression laid out in computer memory (or across a network of computers), then there’ll be a certain time to “collect information spatially from across the expression”, and a certain time that can be attributed to each update event. And the essence of array programming (and much of the operation of GPUs) is that one can assume—like in the typical human experience of physical space—that “all of space” is being updated “together”. </p>
<p>But in our analysis above, we haven’t assumed this, and instead we’ve drawn causal graphs that explicitly trace dependencies between events, and show which events can be considered to be spacelike separated, so that they can be treated as “simultaneous”. </p>
<p>We’ve also seen branchlike separation. In the physics case, the <a href="https://writings.stephenwolfram.com/2022/03/on-the-concept-of-motion/#motion-beyond-physical-space-the-branchial-case">assumption is that we as observers sample in an aggregated way across extended regions in branchial space</a>—just as we do across extended regions in physical space. And indeed the expectation is that we encounter what we describe as “quantum effects” precisely because we are of limited extent in branchial space. </p>
<p>In the case of expression evaluation, we’re not used to being extended in branchial space. We typically imagine that we’ll follow some particular evaluation path (say, as defined by the standard Wolfram Language evaluator), and be oblivious to other paths. But, for example, strategies like speculative execution (typically applied at the hardware level) can be thought of as representing extension in branchial space.</p>
<p>And at a theoretical level, one certainly thinks of different kinds of “observations” in branchial space. In particular, there’s nondeterministic computation, in which one tries to identify a particular “thread of history” that reaches a given state, or a state with some property one wants. </p>
<p>One crucial feature of observers like us is that we are computationally bounded—which puts limitations on the kinds of observations we can make. And for example computational irreducibility then limits what we can immediately know (and aggregate) about the evolution of systems through time. And similarly multicomputational irreducibility limits what we can immediately know (and aggregate) about how systems behave across branchial space. And insofar as any computational devices we build in practice must be ones that we as observers can deal with, it’s inevitable that they’ll be subject to these kinds of limitations. (And, yes, in talking about quantum computers there tends to be an implicit assumption that we can in effect overcome multicomputational irreducibility, and “knit together” all the different computational paths of history—but it seems implausible that observers like us can actually do this, or can in general derive definite results without expending computationally irreducible effort.) </p>
<p>One further small comment about observers concerns what in physics are called <a href="https://www.wolframphysics.org/technical-introduction/the-updating-process-in-our-models/foliations-of-causal-graphs/#p-346" target="_blank" rel="noopener">closed timelike curves</a>—essentially loops in time. Consider the definition:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723observer10Aimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623observer10img2.png' alt='' title='' width='146' height='14'> </div>
</p></div>
<p>This gives for example the multiway graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623observer10img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623observer10img3.png' alt='' title='' width='186' height='31'> </div>
</p></div>
<p>One can think of this as connecting the future to the past—something that’s sometimes interpreted as “allowing time travel”. But really this is just a more (time-)distributed version of a fixed point. In a fixed point, a single state is constantly repeated. Here a sequence of states (just two in the example given here) get visited repeatedly. The observer could treat these states as continually repeating in a cycle, or could coarse grain and conclude that “nothing perceptible is changing”. </p>
<p>In spacetime we think of observers as making particular choices of simultaneity surfaces—or in effect picking particular ways to “parse” the causal graph of events. In branchtime the analog of this is that observers pick how to parse the multiway graph. Or, put another way, observers get to choose a path through the multiway graph, corresponding to a particular evaluation order or evaluation scheme. In general, there is a tradeoff between the choices made by the observer, and the behavior generated by applying the rules of the system.</p>
<p>But if the observer is computationally bounded, they cannot overcome the computational irreducibility—or multicomputational irreducibility—of the behavior of the system. And as a result, if there is complexity in the detailed behavior of the system, the observer will not be able to avoid it at a detailed level by the choices they make. Though a critical idea of our Physics Project is that by appropriate aggregation, the observer will detect certain aggregate features of the system, that have robust characteristics independent of the underlying details. In physics, this represents a bulk theory suitable for the perception of the universe by observers like us. And presumably there is an analog of this in expression evaluation. But insofar as we’re only looking at the evaluation of expressions we’ve engineered for particular computational purposes, we’re not yet used to seeing “generic bulk expression evaluation”. </p>
<p>But this is exactly what we’ll see if we just <a href="https://www.wolframscience.com/nks/">go out and run &#8220;arbitrary programs&#8221;</a>, say found by enumerating certain classes of programs (like combinators or <a href="https://www.wolframphysics.org/bulletins/2021/02/multiway-turing-machines/" target="_blank" rel="noopener">multiway Turing machines</a>). And for observers like us these will inevitably “seem very much like physics”.</p>
<h2 id="the-tree-structure-of-expressions">The Tree Structure of Expressions</h2>
<p>Although we haven’t talked about this so far, any expression fundamentally <a href="https://reference.wolfram.com/language/ref/TreeForm.html">has a tree structure</a>. So, for example, (1 + (2 + 2)) + (3 + 4) is represented—say internally in the Wolfram Language—as the tree:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img1.png' alt='' title='' width='235' height='172'> </div>
</p></div>
<p>So how does this tree structure interact with the process of evaluation? In practice it means for example that in the standard Wolfram Language evaluator there are two different kinds of recursion going on. The first is the progressive (“timelike”) reevaluation of subexpressions that change during evaluation. And the second is the (“spacelike” or “treelike”) scanning of the tree. </p>
<p>In what we’ve discussed above, we’ve focused on evaluation events and their relationships, and in doing so we’ve concentrated on the first kind of recursion—and indeed we’ve often elided some of the effects of the second kind by, for example, immediately showing the result of evaluating <tt><a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt><tt>[2, 2]</tt> without showing more details of how this happens.</p>
<p>But here now is a more complete representation of what’s going on in evaluating this simple expression:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img2_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img2.png' alt='' title='' width='359' height='348'> </div>
</p></div>
<p>The solid gray lines in this “<a href="https://resources.wolframcloud.com/FunctionRepository/resources/TraceGraph">trace graph</a>” indicate the subparts of the expression tree at each step. The dashed gray lines indicate how these subparts are combined to make expressions. And the red lines indicate actual evaluation events where rules (either built in or specified by definitions) are applied to expressions.</p>
<p>It’s possible to read off things like causal dependence between events from the trace graph. But there’s a lot else going on. Much of it is at some level irrelevant—because it involves recursing into parts of the expression tree (like the head <tt><a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt>) where no evaluation events occur. Removing these parts we then get an elided trace graph in which for example the causal dependence is clearer:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img3.png' alt='' title='' width='88' height='292'> </div>
</p></div>
<p>Here’s the trace graph for the evaluation of <tt>f[5]</tt> with the standard recursive Fibonacci definition</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img4_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img4.png' alt='' title='' width='346' height='583'> </div>
</p></div>
<p>and here’s its elided form:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img5_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img5.png' alt='' title='' width='285' height='520'> </div>
</p></div>
<p>At least when we discussed single-way evaluation above, we mostly talked about timelike and spacelike relations between events. But with tree-structured expressions there are also treelike relations. </p>
<p>Consider the rather trivial definition</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723trees11Aimg6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img7.png' alt='' title='' width='67' height='14'> </div>
</p></div>
<p>and look at the multiway graph for the evaluation of <tt>f[f[0]]</tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img8_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img8.png' alt='' title='' width='109' height='172'> </div>
</p></div>
<p>What is the relation between the event on the left branch, and the top event on the right branch? We can think of them as being treelike separated. The event on the left branch transforms the whole expression tree. But the event on the right branch just transforms a subexpression. </p>
<p>Spacelike-separated events affect disjoint parts in an expression (i.e. ones on distinct branches of the expression tree). But treelike-separated events affect nested parts of an expression (i.e. ones that appear on a single branch in the expression tree). Inevitably, treelike-separated events also have a kind of one-way branchlike separation: if the “higher event” in the tree happens, the “lower one” cannot. </p>
<p>In terms of Wolfram Language part numbers, spacelike-separated events affect parts with disjoint numbers, say <tt>{2, 5}</tt> and <tt>{2, 8}</tt>. But treelike-separated events affect parts with overlapping sequences of part numbers, say <tt>{2}</tt> and <tt>{2, 5}</tt> or <tt>{2, 5}</tt> and <tt>{2, 5, 1}</tt>. </p>
<p>In our Physics Project there’s nothing quite like treelike relations built in. The “atoms of space” are <a href="https://writings.stephenwolfram.com/2020/04/finally-we-may-have-a-path-to-the-fundamental-theory-of-physics-and-its-beautiful/#what-is-space">related by a hypergraph</a>—without any kind of explicit hierarchical structure. The hypergraph can take on what amounts to a hierarchical structure, but the fundamental transformation rules won’t intrinsically take account of this.</p>
<p>The hierarchical structure of expressions is incredibly important in their practical use—where it presumably leverages the <a href="https://reference.wolfram.com/language/ref/TextStructure.html">hierarchical structure of human language</a>, and of ways we talk about the world:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img9_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623tree11img9.png' alt='' title='' width='599' height='183'> </div>
</p></div>
<p>We’ll see soon below that we can in principle represent expressions without having hierarchical structure explicitly built in. But in almost all uses of expressions—say in Wolfram Language—we end up needing to have hierarchical structure. </p>
<p>If we were only doing single-way evaluation the hierarchical structure of expressions would be important in determining the order of evaluation to be used, but it wouldn’t immediately enmesh with core features of the evaluation process. But in multiway evaluation “higher” treelike-separated events can in effect cut off the evaluation histories of “lower” ones—and so it’s inevitably central to the evaluation process. For spacelike- and branchlike-separated events, we can always choose different reference frames (or different spacelike or branchlike surfaces) that arrange the events differently. But treelike-separated events—a little like timelike-separated ones—have a certain forced relationship that cannot be affected by an observer’s choices.</p>
<h2 id="grinding-everything-down-to-hypergraphs">Grinding Everything Down to Hypergraphs</h2>
<p>To draw causal graphs—and in fact to do a lot of what we’ve done here—we need to know “what depends on what”. And with our normal setup for expressions this can be quite subtle and complicated. We apply the rule <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img1.png' width= '114' height='15' align='absmiddle'></span> to <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img2.png' width= '37' height='15' align='absmiddle'></span> to give the result <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img3.png' width= '35' height='15' align='absmiddle'></span>. But does the a that “comes out” depend on the a that went in, or is it somehow something that’s “independently generated”? Or, more extremely, in a transformation like <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img4.png' width= '130' height='12' align='absmiddle'></span>, to what extent is it “the same 1” that goes in and comes out? And how do these issues of dependence work when there are the kinds of treelike relations discussed in the previous section?</p>
<p>The Wolfram Language evaluator defines how expressions should be evaluated—but doesn’t immediately specify anything about dependencies. Often we can look “after the fact” and deduce what “was involved” and what was not—and thus what should be considered to depend on what. But it’s not uncommon for it to be hard to know what to say—forcing one to make what seem likely arbitrary decisions. So is there any way to avoid this, and to set things up so that dependency becomes somehow “obvious”? </p>
<p>It turns out that there is—though, perhaps not surprisingly, it comes with difficulties of its own. But the basic idea is to go “below expressions”, and to “grind everything down” to hypergraphs whose nodes are ultimate direct “carriers” of identity and dependency. It’s all deeply reminiscent of our Physics Project—and its <a href="https://writings.stephenwolfram.com/2021/11/the-concept-of-the-ruliad/">generalization in the ruliad</a>. Though in those cases the individual elements (or “emes” as we call them) exist far below the level of human perception, while in the hypergraphs we construct for expressions, things like symbols and numbers appear directly as emes.</p>
<p>So how can we “compile” arbitrary expressions to hypergraphs? In the Wolfram Language something like <em>a</em> + <em>b</em> + <em>c</em> is the “full-form” expression</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img6.png' alt='' title='' width='88' height='14'> </div>
</p></div>
<p>which corresponds to the tree:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img7_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img7.png' alt='' title='' width='114' height='69'> </div>
</p></div>
<p>And the point is that we can represent this tree by a hypergraph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img8_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img8.png' alt='' title='' width='145' height='144'> </div>
</p></div>
<p><tt>Plus</tt>, <em>a</em>, <em>b</em> and <em>c</em> appear directly as “content nodes” in the hypergraph. But there are also “infrastructure nodes” (here labeled with integers) that specify how the different pieces of content are “related”—here with a 5-fold hyperedge representing <tt><a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt> with three arguments. We can write this hypergraph out in “symbolic form” as:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img9_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img9.png' alt='' title='' width='295' height='20'> </div>
</p></div>
<p>Let’s say instead we have the expression <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img10.png' width= '69' height='15' align='absmiddle'></span> or <tt><a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt><tt>[a, <a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt><tt>[b, c]]</tt>, which corresponds to the tree:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img11_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img11.png' alt='' title='' width='98' height='128'> </div>
</p></div>
<p>We can represent this expression by the hypergraph</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img12_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img12.png' alt='' title='' width='386' height='20'> </div>
</p></div>
<p>which can be rendered visually as:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img13_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img13.png' alt='' title='' width='217' height='164'> </div>
</p></div>
<p>What does evaluation do to such hypergraphs? Essentially it must transform collections of hyperedges into other collections of hyperedges. So, for example, when <tt>x_ + y_</tt> is evaluated, it transforms a set of 3 hyperedges to a single hyperedge according to the rule:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img15_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img15.png' alt='' title='' width='408' height='14'> </div>
</p></div>
<p>(Here the list on the left-hand side represents three hyperedges in any order—and so is effectively assumed to be <a href="https://reference.wolfram.com/language/ref/Orderless.html">orderless</a>.) In this rule, the literal <tt><a href="http://reference.wolfram.com/language/ref/Plus.html">Plus</a></tt> acts as a kind of key to determine what should happen, while the specific patterns define how the input and output expressions should be “knitted together”.</p>
<p>So now let’s apply this rule to the expression 10 + (20 + 30). The expression corresponds to the hypergraph</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img16_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img16.png' alt='' title='' width='408' height='20'> </div>
</p></div>
<p>where, yes, there are integers both as content elements, and as labels or IDs for “infrastructure nodes”. The rule operates on collections of hyperedges, always consuming 3 hyperedges, and generating 1. We can think of the hyperedges as “fundamental tokens”. And now we can draw a <a href="https://writings.stephenwolfram.com/2021/09/multicomputation-a-fourth-paradigm-for-theoretical-science/#the-formal-structure-of-multicomputation">token-event graph</a> to represent the evaluation process:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img17_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img17.png' alt='' title='' width='253' height='170'> </div>
</p></div>
<p>Here’s the slightly more complicated case of (10 + (20 + 20)) + (30 + 40):</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img18_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img18.png' alt='' title='' width='349' height='202'> </div>
</p></div>
<p>But here now is the critical point. By looking at whether there are emes in common from one event to another, we can determine whether there is dependency between those events. Emes are in a sense “atoms of existence” that maintain a definite identity, and immediately allow one to trace dependency. </p>
<p>So now we can fill in causal edges, with each edge labeled by the emes it “carries”:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923grindingupdateimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092923grindingupdateimg1.png' alt='' title='' width='466' height='317'> </div>
</p></div>
<p>Dropping the hyperedges, and adding in an initial “Big Bang” event, we get the (multiway) causal graph:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923grindingupdateimg2_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092923grindingupdateimg2.png' alt='' title='' width='476' height='300'> </div>
</p></div>
<p>We should note that in the token-event graph, each expression has been “shattered” into its constituent hyperedges. Assembling the tokens into recognizable expressions effectively involves setting up a particular foliation of the token-event graph. But if we do this, we get a multiway graph expressed in terms of hypergraphs</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img21_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img21-v2.png' alt='' title='' width='651' height='301'> </div>
</p></div>
<p>or in visual form:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img12_copy.txt' data-c2c-type='text/html'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img22.png' alt='' title='' width='208' height='575'> </div>
</p></div>
<p>As a slightly more complicated case, consider the recursive computation of the Fibonacci number <tt>f[2]</tt>. Here is the token-event graph in this case:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img23_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img23.png' alt='' title='' width='549' height='238'> </div>
</p></div>
<p>And here is the corresponding multiway causal graph, labeled with the emes that “carry causality”:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img24_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img24.png' alt='' title='' width='448' height='325'> </div>
</p></div>
<p>Every kind of expression can be “ground down” in some way to hypergraphs. For strings, for example, it’s <a href="https://www.wolframphysics.org/technical-introduction/equivalence-and-computation-in-our-models/correspondence-with-other-systems/" target="_blank" rel="noopener">convenient to make a separate token out of every character</a>, so that “ABBAAA” can be represented as:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img14_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623grinding11img25.png' alt='' title='' width='404' height='13'> </div>
</p></div>
<p>It’s interesting to note that our hypergraph setup can have a certain similarity to machine-level representations of expressions, with every eme in effect corresponding to a pointer to a certain memory location. Thus, for example, in the representation of the string, the infrastructure emes define the pointer structure for a linked list—with the content emes being the “payloads” (and pointing to globally shared locations, like ones for A and B). </p>
<p>Transformations obtained by applying rules can then be thought of as corresponding just to rearranging pointers. Sometimes “new emes” have to be created, corresponding to new memory being allocated. We don’t have an explicit way to “free” memory. But sometimes some part of the hypergraph will become disconnected—and one can then imagine disconnected pieces to which the observer is not attached being garbage collected.</p>
<h2 id="the-rulial-case">The Rulial Case</h2>
<p>So far we’ve discussed what happens in the evaluation of particular expressions according to particular rules (where those rules could just be all the ones that are built into Wolfram Language). But the concept of the ruliad suggests thinking about all possible computations—or, in our terms here, all possible evaluations. Instead of particular expressions, we are led to think about evaluating all possible expressions. And we are also led to think about using all possible rules for these evaluations.</p>
<p>As one simple approach to this, instead of looking, for example, at a single combinator definition such as</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723rulial13Aimg1_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img1.png' alt='' title='' width='168' height='14'> </div>
</p></div>
<p>used to evaluate a single expression such as</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img2_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img2.png' alt='' title='' width='108' height='14'> </div>
</p></div>
<p>we can start enumerating all possible combinator rules</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092923codeupdates2img16_copy.txt' data-c2c-type='text/html'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img3.png' alt='' title='' width='488' height='76'> </div>
</p></div>
<p>and apply them to evaluate all possible expressions:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img4_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img4.png' alt='' title='' width='484' height='74'> </div>
</p></div>
<p>Various new phenomena show up here. For example, there is now immediately the possibility of not just spacelike and branchlike separation, but also what we can call rulelike separation.</p>
<p>In a trivial case, we could have rules like</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img5_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img5.png' alt='' title='' width='97' height='14'> </div>
</p></div>
<p>and then evaluating <em>x</em> will lead to two events which we can consider rulelike separated:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img6_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img6.png' alt='' title='' width='97' height='101'> </div>
</p></div>
<p>In the standard Wolfram Language system, the definitions <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092623rulial13img7.png' width= '37' height='9' align='absmiddle'></span> and <em>x</em> = <em>b</em> would overwrite each other. But if we consider rulial multiway evaluation, we’d have branches for each of these definitions.</p>
<p>In what we’ve discussed before, we effectively allow evaluation to take infinite time, as well as infinite space and infinite branchial space. But now we’ve got the new concept of infinite rulial space. We might say from the outset that, for example, we’re going to use all possible rules. Or we might have what amounts to a dynamical process that generates possible rules. </p>
<p>And the key point is that as soon as that process is in effect computation universal, there is a way to translate from one instance of it to another. Different specific choices will lead to a different basis—but in the end they’ll all eventually generate the full ruliad. </p>
<p>And actually, this is where the whole concept of expression evaluation ultimately merges with fundamental physics. Because in both cases, the limit of what we’re doing will be exactly the same: the full ruliad.</p>
<h2 id="the-practical-computing-story">The Practical Computing Story</h2>
<p>The formalism we’ve discussed here—and particularly its correspondence with fundamental physics—is in many ways a new story. But it has precursors that go back more than a century. And indeed as soon as industrial processes—and production lines—began to be formalized, it became important to understand interdependencies between different parts of a process. By the <a href="https://www.wolframscience.com/nks/notes-9-9--causal-networks/">1920s flowcharts had been invented</a>, and when digital computers were developed in the 1940s they began to be used to represent the “flow” of programs (and in fact <a href="https://writings.stephenwolfram.com/2015/12/untangling-the-tale-of-ada-lovelace/#babbages-secret-sauce">Babbage had used something similar</a> even in the 1840s). At first, at least as far as programming was concerned, it was all about the “flow of control”—and the sequence in which things should be done. But by the 1970s the notion of the “flow of data” was also widespread—in some ways reflecting back to actual flow of electrical signals. In some simple cases various forms of “visual programming”—typically based on connecting virtual wires—have been popular. And even in modern times, it’s not uncommon to talk about “<a href="https://reference.wolfram.com/language/ref/NetGraph.html">computation graphs</a>” as a way to specify how data should be routed in a computation, for example in sequences of operations on tensors (say for neural net applications).</p>
<p>A different tradition—originating in mathematics in the late 1800s—involved the routine use of “abstract functions” like <em>f</em>(<em>x</em>). Such abstract functions could be used both “symbolically” to represent things, and explicitly to “compute” things. All sorts of (often ornate) formalism was developed in mathematical logic, with <a href="https://writings.stephenwolfram.com/2020/12/combinators-and-the-story-of-computation/">combinators arriving in 1920</a>, and lambda calculus in 1935. By the late 1950s <a href="https://writings.stephenwolfram.com/2020/12/combinators-and-the-story-of-computation/#practical-computation">there was LISP</a>, and by the 1970s there was a definite tradition of “functional programming” involving the processing of things by successive application of different functions. </p>
<p>The question of what really depended on what became more significant whenever there was the possibility of doing computations in parallel. This was already being discussed in the 1960s, but became more popular in the early 1980s, and in a sense finally “went mainstream” with GPUs in the 2010s. And indeed our discussion of causal graphs and spacelike separation isn’t far away from the kind of thing that’s often discussed in the context of designing parallel algorithms and hardware. But one difference is that in those cases one’s usually imagining having a “static” flow of data and control, whereas here we’re routinely considering causal graphs, etc. that are being created “on the fly” by the actual progress of a computation.</p>
<p>In many situations—with both algorithms and hardware—one has precise control over when different “events” will occur. But in distributed systems it’s also common for events to be asynchronous. And in such cases, it’s possible to have “conflicts”, “race conditions”, etc. that correspond to branchlike separation. There have been various attempts—many originating in the 1970s—to develop formal “process calculi” to describe such systems. And in some ways what we’re doing here can be seen as a physics-inspired way to clarify and extend these kinds of approaches. </p>
<p>The concept of <a href="https://www.wolframscience.com/nksonline/page-938b/">multiway systems also has a long history</a>—notably appearing in the early 1900s in connection with game graphs, formal group theory and various problems in combinatorics. Later, multiway systems would implicitly show up in considerations of automated theorem proving and nondeterministic computation. In practical microprocessors it’s been common for a decade or so to do “speculative execution” where multiple branches in code are preemptively followed, keeping only the one that’s relevant given actual input received.</p>
<p>And when it comes to branchlike separation, a notable practical example arises in version control and collaborative editing systems. If a piece of text has changes at two separated places (“spacelike separation”), then these changes (“diffs”) can be applied in any order. But if these changes involve the same content (e.g. same characters) then there can be a conflict (“merge conflict”) if one tries to apply the changes—in effect reflecting the fact that these changes were made by branchlike-separated “change events” (and to trace them requires creating different “forks” or what we might call different histories).</p>
<p>It’s perhaps worth mentioning that as soon as one has the concept of an “expression” one is led to the concept of “evaluation”—and as we’ve seen many times here, that’s even true for arithmetic expressions, like 1 + (2 + 3). We’ve been particularly concerned with questions about “what depends on what” in the process of evaluation. But in practice there’s often also the question of when evaluation happens. The Wolfram Language, for example, distinguishes between “<a href="https://reference.wolfram.com/language/ref/Set.html">immediate evaluation</a>” done when a definition is made, and “<a href="https://reference.wolfram.com/language/ref/SetDelayed.html">delayed evaluation</a>” done when it’s used. There’s also lazy evaluation where what’s immediately generated is a symbolic representation of the computation to be done—with steps or pieces being explicitly computed only later, when they are requested. </p>
<p>But what really is “<a href="https://reference.wolfram.com/language/tutorial/EvaluationOfExpressions.html">evaluation</a>”? If our “input expression” is 1 + 1, we typically think of this as “defining a computation that can be done”. Then the idea of the “process of evaluation” is that it does that computation, deriving a final “value”, here 2. And one view of the Wolfram Language is that its whole goal is to set up a collection of transformations that do as many computations that we know how to do as possible. Some of those transformations effectively incorporate “factual knowledge” (like knowledge of mathematics, or chemistry, or geography). But some are more abstract, like transformations defining how to do transformations, say on patterns. </p>
<p>These abstract transformations are in a sense the easiest to trace—and often above that’s what we’ve concentrated on. But usually we’ve allowed ourselves to do at least some transformations—like adding numbers—that are built into the “insides” of the Wolfram Language. It’s perhaps worth mentioning that in conveniently representing such a broad range of computational processes the Wolfram Language ends up having some <a href="https://reference.wolfram.com/language/tutorial/EvaluationOfExpressions.html">quite elaborate evaluation mechanisms</a>. A common example is the idea of functions that “hold their arguments”, evaluating them only as “specifically requested” by the innards of the function. Another—that in effect creates a “side chain” to causal graphs—are conditions (e.g. <a href="https://reference.wolfram.com/language/ref/Condition.html">associated with <tt>/;</tt></a>) that need to be evaluated to determine whether patterns are supposed to match. </p>
<p>Evaluation is in a sense the central operation in the Wolfram Language. And what we’ve seen here is that it has a deep correspondence with what we can view as the “central operation” of physics: the passage of time. Thinking in terms of physics helps organize our thinking about the process of evaluation—and it also suggests some important generalizations, like multiway evaluation. And one of the challenges for the future is to see how to take such generalizations and “package” them as part of our computational language in a form that we humans can readily understand and make use of.</p>
<h2 id="some-personal-history-recursion-control-in-smp">Some Personal History: Recursion Control in SMP</h2>
<p>It was in late 1979 that I first started to <a href="https://writings.stephenwolfram.com/2013/06/there-was-a-time-before-mathematica/">design my SMP (&#8220;Symbolic Manipulation Program&#8221;) system</a>. I’d studied both practical computer systems and ideas from mathematical logic. And one of my conclusions was that any definition you made should always get used, whenever it could. If you set <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img1.png' width= '37' height='11' align='absmiddle'></span>, then you set <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img2.png' width= '35' height='11' align='absmiddle'></span>, you should get <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img3.png' width= '7' height='8' align='absmiddle'></span> (not <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img4.png' width= '9' height='11' align='absmiddle'></span>) if you asked for <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img5.png' width= '8' height='8' align='absmiddle'></span>. It’s what most people would expect should happen. But like almost all fundamental design decisions, in addition to its many benefits, it had some unexpected consequences. For example, it meant that if you set <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img6.png' width= '60' height='9' align='absmiddle'></span> without having given a value for <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img7.png' width= '8' height='8' align='absmiddle'></span>, you’d in principle get an infinite loop.</p>
<p>Back in 1980 there were computer scientists who asserted that this meant the “infinite evaluation” I’d built into the core of SMP “could never work”. Four decades of experience tells us rather definitively that in practice they were wrong about this (essentially because people just don’t end up “falling into the <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img8.png' width= '60' height='9' align='absmiddle'></span> pothole” when they’re doing actual computations they want to do). But questions like those about <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img9.png' width= '60' height='9' align='absmiddle'></span> made me particularly aware of issues around recursive evaluation. And it bothered me that a recursive factorial definition like <tt>f[n_]:=n f[n–1]</tt> (the rather less elegant SMP notation was <span class="computer-voice">f[$n]::$n f[$1-1]</span>) might just run infinitely if it didn’t have a base case (<span class="computer-voice">f[1] = 1</span>), rather than terminating with the value 0, which it “obviously should have”, given that at some point one’s computing 0×&#8230;.</p>
<p>So in SMP I invented a rather elaborate scheme for recursion control that “solved” this problem. And here’s what happens in SMP (now running on a reconstructed virtual machine):</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img11_v2.png' alt='SMP code' title='SMP code' width='592' height='146'/></p>
<p>And, yes, if one includes the usual base case for factorial, one gets the usual answer:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img13_v2.png' alt='SMP code' title='SMP code' width='592' height='111'/></p>
<p>So what is going on here? Section 3.1 of the SMP documentation in principle tells the story. In SMP I used the term “simplification” for what I’d now call “evaluation”, both because I imagined that most transformations one wanted would make things “simpler” (as in <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img14.png' width= '61' height='9' align='absmiddle'></span>), and because there was a nice pun between the name SMP and the function <span class="computer-voice">Smp</span> that carried out the core operation of the system (yes, SMP rather foolishly used short names for built-in functions). Also, it’s useful to know that in SMP I called an ordinary expression like <span class="computer-voice">f[x, y, &#8230;]</span> a “projection”: its “head” <span class="computer-voice">f</span> was called its “projector”, and its arguments <span class="computer-voice">x, y</span>, &#8230; were called “filters”.</p>
<p>As the <a href="https://files.wolframcdn.com/pub/www.stephenwolfram.com/pdf/smp-manual.pdf" target="_blank" rel="noopener">Version 1.0 documentation from July 1981</a> tells it, “simplification” proceeds like this:</p>
<p><a class='magnific image' alt='' title='' href='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img17.png'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img17.png' alt='Click to enlarge' title='Click to enlarge' width='620' height='374'/></a></p>
<p>By the next year, <a href="https://content.wolfram.com/sw-publications/2020/07/smp-summary.pdf">it was a bit more sophisticated</a>, though the default behavior didn’t change:</p>
<p><a class='magnific image' alt='' title='' href='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img20.png'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img20.png' alt='Click to enlarge' title='Click to enlarge' width='620' height='497'/></a></p>
<p>With the definitions above, the value of <span class="computer-voice">f</span> itself was (compare <tt><a href="http://reference.wolfram.com/language/ref/Association.html">Association</a></tt> in Wolfram Language):</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img22_v2.png' alt='SMP code' title='SMP code' width='592' height='80'/></p>
<p>But the key to evaluation without the base case actually came in the “properties” of multiplication:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img24_v2.png' alt='SMP code' title='SMP code' width='592' height='101'/></p>
<p>In SMP <span class="computer-voice">True</span> was (foolishly) 1. It’s notable here that <span class="computer-voice">Flat</span> corresponds to the attribute <tt><a href="http://reference.wolfram.com/language/ref/Flat.html">Flat</a></tt> in Wolfram Language, <span class="computer-voice">Comm</span> to <tt><a href="http://reference.wolfram.com/language/ref/Orderless.html">Orderless</a></tt> and <span class="computer-voice">Ldist</span> to <tt><a href="http://reference.wolfram.com/language/ref/Listable.html">Listable</a></tt>. (<span class="computer-voice">Sys</span> indicated that this was a built-in system function, while <span class="computer-voice">Tier</span> dealt with weird consequences of the attempted unification of arrays and functions into an association-like construct.) But the critical property here was <span class="computer-voice">Smp</span>. By default its value was <span class="computer-voice">Inf</span> (for <a href="https://reference.wolfram.com/language/ref/Infinity.html"><tt>Infinity</tt></a>). But for <span class="computer-voice">Mult</span> (<a href="https://reference.wolfram.com/language/ref/Times.html"><tt>Times</tt></a>) it was 1. </p>
<p>And what this did was to tell the SMP evaluator that inside any multiplication, it should allow a function (like <span class="computer-voice">f</span>) to be called recursively at most once before the actual multiplication was done. Telling SMP to trace the evaluation of <span class="computer-voice">f[5]</span> we then see:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img26_v2.png' alt='SMP code' title='SMP code' width='592' height='359'/></p>
<p>So what’s going on here? The first time <span class="computer-voice">f</span> appears inside a multiplication its definition is used. But when <span class="computer-voice">f</span> appears recursively a second time, it’s effectively frozen—and the multiplication is done using its frozen form, with the result that as soon as a 0 appears, one just ends up with 0.</p>
<p>Reset the <span class="computer-voice">Smp</span> property of <span class="computer-voice">Mult</span> to infinity, and the evaluation runs away, eventually producing a rather indecorous crash:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img29_v2.png' alt='SMP code' title='SMP code' width='592' height='547'/></p>
<p>In effect, the <span class="computer-voice">Smp</span> property defines how many recursive evaluations of arguments should be done before a function itself is evaluated. Setting the <span class="computer-voice">Smp</span> property to 0 has essentially the same effect as the <tt><a href="http://reference.wolfram.com/language/ref/HoldAll.html">HoldAll</a></tt> attribute in Wolfram Language: it prevents arguments from being evaluated until a function as a whole is evaluated. Setting <span class="computer-voice">Smp</span> to value <em>k</em> basically tells SMP to do only <em>k</em> levels of “depth-first” evaluation before collecting everything together to do a “breadth-first evaluation”.</p>
<p>Let’s look at this for a recursive definition of Fibonacci numbers:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img31_v2.png' alt='SMP code' title='SMP code' width='592' height='101'/></p>
<p>With the <span class="computer-voice">Smp</span> property of <span class="computer-voice">Plus</span> set to infinity, the sequence of evaluations of <span class="computer-voice">f</span> follows a pure “depth-first” pattern</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img33_v2.png' alt='SMP code' title='SMP code' width='620' height='513'/></p>
<p>where we can plot the sequence of <tt>f[</tt><em>n</em><tt>]</tt> evaluated as:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img34_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img34-v2.png' alt='' title='' width='666' height='187'> </div>
</p></div>
<p>But with the default setting of 1 for the <span class="computer-voice">Smp</span> property of <span class="computer-voice">Plus</span> the sequence is different</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img36_v2.png' alt='SMP code' title='SMP code' width='620' height='683'/></p>
<p>and now the sequence of <tt>f[</tt><em>n</em><tt>]</tt> evaluated is:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img37_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img37-v2.png' alt='' title='' width='666' height='187'> </div>
</p></div>
<p>In the pure depth-first case all the exponentially many leaves of the Fibonacci tree are explicitly evaluated. But now the evaluation of <span class="computer-voice">f[</span><em>n</em><span class="computer-voice">]</span> is being frozen after each step and terms are being collected and combined. Starting for example from <span class="computer-voice">f[10]</span> we get <span class="computer-voice">f[9]</span>&hairsp;<span class="computer-voice">+</span>&hairsp;<span class="computer-voice">f[8]</span>. And evaluating another step we get <nobr><span class="computer-voice">f[8]</span>&hairsp;<span class="computer-voice">+</span>&hairsp;<span class="computer-voice">f[7]</span>&hairsp;<span class="computer-voice">+</span>&hairsp;<span class="computer-voice">f[7]</span>&hairsp;<span class="computer-voice">+</span>&hairsp;<span class="computer-voice">f[6]</span></nobr>. But now the <span class="computer-voice">f[7]</span>’s can be combined into <nobr><span class="computer-voice">f[8]</span>&hairsp;<span class="computer-voice">+</span>&hairsp;<span class="computer-voice">2f[7]</span>&hairsp;<span class="computer-voice">+</span>&hairsp;<span class="computer-voice">f[6]</span></nobr> so that they don’t both have to separately be evaluated. And in the end only quadratically many separate evaluations are needed to get the final result.</p>
<p>I don’t now remember quite why I put it in, but SMP also had another piece of recursion control: the <span class="computer-voice">Rec</span> property of a symbol—which basically meant “it’s OK for this symbol to appear recursively; don’t count it when you’re trying to work out whether to freeze an evaluation”. </p>
<p>And it’s worth mentioning that SMP also had a way to handle the original <span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img38.png' width= '60' height='9' align='absmiddle'></span> issue:</p>
<p><a class='magnific image' alt='' title='' href='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img40.png'><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img40.png' alt='Click to enlarge' title='Click to enlarge' width='548' height='71'/></a></p>
<p>It wasn’t a terribly general mechanism, but at least it worked in this case:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723recursion15img42_v2.png' alt='SMP code' title='SMP code' width='592' height='80'/></p>
<p>I always thought that SMP’s “wait and combine terms before recursing” behavior was quite clever, but beyond the factorial and Fibonacci examples here I’m not sure I ever found clear uses for it. Still, with our current physics-inspired way of looking at things, we can see that this behavior basically corresponded to picking a “more spacetime-like” foliation of the evaluation graph.</p>
<p>And it’s a piece of personal irony that right around the time I was trying to figure out recursive evaluation in SMP, I was also <a href="https://www.stephenwolfram.com/publications/academic/particle-physics/">working on gauge theories in physics</a>—which in the end involve very much the same kinds of issues. But it took another four decades—and the development of our Physics Project—before I saw the fundamental connection between these things.</p>
<h2 id="after-smp-further-personal-history">After SMP: Further Personal History</h2>
<p>The idea of parallel computation was one that I was already thinking about at the very beginning of the 1980s—partly at a theoretical level for things like neural nets and cellular automata, and partly at a practical level for SMP (and indeed by 1982 I had described a <span class="computer-voice">Ser</span> property in SMP that was supposed to ensure that the arguments of a particular function would always get evaluated in a definite order “in series”). Then in 1984 I was involved in trying to design a <a href="https://writings.stephenwolfram.com/2016/04/my-life-in-technology-as-told-at-the-computer-history-museum/">general language for parallel computation on the Connection Machine</a> “massively parallel” computer. The “obvious” approach was just to assume that programs would be set up to operate in steps, even if at each step many different operations might happen in parallel. But I somehow thought that there must be a better approach, somehow based on graphs, and graph rewriting. But back then I didn’t, for example, think of formulating things in terms of causal graphs. And while I knew about phenomena like race conditions, I hadn’t yet internalized the idea of constructing multiway graphs to “represent all possibilities”. </p>
<p>When I started designing Mathematica—and what’s now the Wolfram Language—in 1986, I used the same core idea of transformation rules for symbolic expressions that was the basis for SMP. But I was able to greatly streamline the way expressions and their evaluation worked. And not knowing compelling use cases, I decided not to set up the kind of elaborate recursion control that was in SMP, and instead just to concentrate on basically two cases: functions with ordinary (essentially leftmost-innermost) evaluation and functions with held-argument (essentially outermost) evaluation. And I have to say that in three decades of usages and practical applications I haven’t really missed having more elaborate recursion controls.</p>
<p>In working on <em><a href="https://www.wolframscience.com/nks/">A New Kind of Science</a></em> in the 1990s, issues of evaluation order <a href="https://www.wolframscience.com/nks/notes-3-10--order-dependence-in-symbolic-systems/">first came up</a> in connection with “symbolic systems” (essentially, generalized combinators). They then came up more poignantly when I explored the possible computational “infrastructure” for spacetime—and indeed that was <a href="https://www.wolframscience.com/nks/chap-9--fundamental-physics#sect-9-9--time-and-causal-networks">where I first started explicitly discussing and constructing causal graphs</a>. </p>
<p>But it was not until 2019 and early 2020, with the development of our Physics Project, that clear concepts of spacelike and branchlike separation for events emerged. The correspondence with expression evaluation got clearer in December 2020 when—in connection with the <a href="https://writings.stephenwolfram.com/2020/12/where-did-combinators-come-from-hunting-the-story-of-moses-schonfinkel/">centenary of their invention</a>—I did an <a href="https://writings.stephenwolfram.com/2020/12/combinators-a-centennial-view/">extensive investigation of combinators</a> (leading to my book <em><a href="https://www.wolfram-media.com/products/combinators-a-centennial-view/">Combinators</a></em>). And as I started to explore the <a href="https://writings.stephenwolfram.com/2021/09/multicomputation-a-fourth-paradigm-for-theoretical-science/">general concept of multicomputation</a>, and its many potential applications, I soon saw the need for systematic ways to think about multicomputational evaluation in the context of symbolic language and symbolic expressions. </p>
<p>In both SMP and Wolfram Language the main idea is to “get results”. But particularly for debugging it’s always been of interest to see some kind of trace of how the results are obtained. In SMP—as we saw above—there was a <span class="computer-voice">Trace</span> property that would cause any evaluation associated with a particular symbol to be printed. But what about an actual computable representation of the “trace”? In 1990 we introduced the function <tt><a href="http://reference.wolfram.com/language/ref/Trace.html">Trace</a></tt> in the Wolfram Language—which produces what amounts to a symbolic representation of an evaluation process. </p>
<p>I had high hopes for <tt><a href="http://reference.wolfram.com/language/ref/Trace.html">Trace</a></tt>—and for its ability to turn things like control flows into structures amenable to direct manipulation. But somehow what <tt><a href="http://reference.wolfram.com/language/ref/Trace.html">Trace</a></tt> produces is almost always too difficult to understand in real cases. And for many years I kept the problem of “making a better <tt><a href="http://reference.wolfram.com/language/ref/Trace.html">Trace</a></tt>” on my to-do list, though without much progress. </p>
<p>The problem of “exposing a process of computation” is quite like the problem of presenting a proof. And in 2000 I had occasion to use automated theorem proving to <a href="https://writings.stephenwolfram.com/2018/11/logic-explainability-and-the-future-of-understanding/">produce a long proof of my minimal axiom system for Boolean algebra</a>. We wanted to introduce such methods into Mathematica (or what’s now the Wolfram Language). But we were stuck on the question of how to represent proofs—and in 2007 we ended up integrating just the “answer” part of the methods into the function <tt><a href="http://reference.wolfram.com/language/ref/FullSimplify.html">FullSimplify</a></tt>. </p>
<p>By the 2010s we’d had the experience of producing step-by-step explanations in <a href="https://www.wolframalpha.com/">Wolfram|Alpha</a>, as well as exploring proofs in the context of <a href="https://writings.stephenwolfram.com/2014/08/computational-knowledge-and-the-future-of-pure-mathematics/">representing pure-mathematical knowledge</a>. And finally in 2018 we introduced <tt><a href="http://reference.wolfram.com/language/ref/FindEquationalProof.html">FindEquationalProof</a></tt>, which provided a symbolic representation of proofs—at least ones based on successive pattern matching and substitution—as well as a graphical representation of the relationships between lemmas.</p>
<p>After the arrival of our Physics Project—as well as my exploration of combinators—I returned to questions about the foundations of mathematics and developed a whole “<a href="https://writings.stephenwolfram.com/2022/03/the-physicalization-of-metamathematics-and-its-implications-for-the-foundations-of-mathematics/">physicalization of metamathematics</a>” based on tracing what amount to multiway networks of proofs. But the steps in these proofs were still in a sense purely structural, involving only pattern matching and substitution. </p>
<p>I explored other applications of “multicomputation”, generating <a href="https://www.wolframphysics.org/bulletins/2021/10/multicomputation-with-numbers-the-case-of-simple-multiway-systems" target="_blank" rel="noopener">multiway systems based on numbers</a>, <a href="https://writings.stephenwolfram.com/2022/06/games-and-puzzles-as-multicomputational-systems/">multiway systems representing games</a>, and so on. And I kept on wondering—and sometimes doing livestreamed discussions about—how best to create a language design around multicomputation. And as a first step towards that, we developed the <tt><a href="https://resources.wolframcloud.com/FunctionRepository/resources/TraceGraph/">TraceGraph</a></tt> function in the <a href="https://resources.wolframcloud.com/FunctionRepository/">Wolfram Function Repository</a>, which finally provided a somewhat readable graphical rendering of the output of <tt><a href="http://reference.wolfram.com/language/ref/Trace.html">Trace</a></tt><tt>—</tt>and began to show the causal dependencies in at least single-way computation. But what about the multiway case? For the Physics Project we’d already developed <tt><a href="https://resources.wolframcloud.com/FunctionRepository/resources/MultiwaySystem">MultiwaySystem</a></tt> and related functions in the Wolfram Function Repository. So now the question was: how could one streamline this and have it provide essentially a multiway generalization of <tt><a href="https://resources.wolframcloud.com/FunctionRepository/resources/TraceGraph/">TraceGraph</a></tt>? We began to think about—and implement—concepts like <tt>Multi</tt>, and imagine ways in which general multicomputation could encompass things like logic programming and probabilistic programming, as well as nondeterministic and quantum computation.</p>
<p>But meanwhile, the “<span class='InlineFormula'><img src='https://content.wolfram.com/sites/43/2023/09/sw092723further16img1.png' width= '60' height='9' align='absmiddle'></span> question” that had launched my whole adventure in recursion control in SMP was still showing up—43 years later—in the Wolfram Language. It had been there since <a href="https://reference.wolfram.com/legacy/v1/">Version 1.0</a>, though it never seemed to matter much, and we’d always handled it just by having a <a href="https://reference.wolfram.com/language/ref/$RecursionLimit.html">global &#8220;recursion limit&#8221;</a>—and then “holding” all further subevaluations:</p>
<p><img loading='lazy' src='https://content.wolfram.com/sites/43/2023/04/sw040123img90A.png' alt='' title='' width='482' height='73'> </p>
<p>But over the years there’d been increasing evidence that this wasn’t quite adequate, and that for example further processing of the held form (even, for example, formatting it) could in extreme cases end up triggering even infinite cascades of evaluations. So finally—in <a href="https://writings.stephenwolfram.com/2022/12/the-latest-from-our-rd-pipeline-version-13-2-of-wolfram-language-mathematica">Version 13.2</a> at the end of last year—we introduced the beginnings of a <a href="https://writings.stephenwolfram.com/2022/12/the-latest-from-our-rd-pipeline-version-13-2-of-wolfram-language-mathematica/#controlling-runaway-computations-">new mechanism to cut off &#8220;runaway&#8221; computations</a>, based on a construct called <tt><a href="http://reference.wolfram.com/language/ref/TerminatedEvaluation.html">TerminatedEvaluation</a></tt>:</p>
<div>
<div class='wolfram-c2c-wrapper writtings-c2c_above' data-c2c-file='https://content.wolfram.com/sites/43/2023/09/sw092723further16img3_copy.txt' data-c2c-type='text/html'> <img loading='lazy' src='https://content.wolfram.com/sites/43/2023/09/sw092723further16img3.png' alt='' title='' width='342' height='72'> </div>
</p></div>
<p>And from the beginning we wanted to see how to encode within <tt><a href="http://reference.wolfram.com/language/ref/TerminatedEvaluation.html">TerminatedEvaluation</a></tt> information about just what evaluation had been terminated. But to do this once again seemed to require having a way to represent the “ongoing process of evaluation”—leading us back to <tt><a href="http://reference.wolfram.com/language/ref/Trace.html">Trace</a></tt>, and making us think about evaluation graphs, causal graphs, etc.</p>
<p>At the beginning <em>x</em> = <em>x</em> + 1 might just have seemed like an irrelevant corner case—and for practical purposes it basically is. But already four decades ago it led me to start thinking not just about the results of computations, but also how their internal processes can be systematically organized. For years, I didn’t really connect this to my work on explicit computational processes like those in systems such as cellular automata. Hints of such connections did start to emerge as I began to try to build computational models of fundamental physics. But looking back I realize that in <em>x</em> = <em>x</em> + 1 there was already in a sense a shadow of what was to come in our Physics Project and in the whole construction of the ruliad. </p>
<p>Because <em>x</em> = <em>x</em> + 1 is something which—like physics and like the ruliad—necessarily generates an ongoing process of computation. One might have thought that the fact that it doesn’t just “give an answer” was in a sense a sign of uselessness. But what we’ve now realized is that our whole existence and experience is based precisely on “living inside a computational process” (which, fortunately for us, hasn’t just “ended with an answer”). Expression evaluation is in its origins intended as a “human-accessible” form of computation. But what we’re now seeing is that its essence also inevitably encompasses computations that are at the core of fundamental physics. And by seeing the correspondence between what might at first appear to be utterly unrelated intellectual directions, we can expect to inform both of them. Which is what I have started to try to do here.</p>
<h2 id="notes-and-thanks" style='font-size:1.2rem'>Notes &#038; Thanks</h2>
<p style='font-size:90%'>What I&#8217;ve described here builds quite directly on some of my recent work, particularly as covered in my books <a href="https://www.wolfram-media.com/products/combinators-a-centennial-view/"><em>Combinators: A Centennial View</em></a> and <a href="https://www.wolfram-media.com/products/metamathematics-foundations-and-physicalization/"><em>Metamathematics: Physicalization &#038; Foundations</em></a>. But as I mentioned above, I started thinking about related issues at the beginning of the 1980s in connection with the design of SMP, and I&#8217;d like to thank members of the SMP development team for discussions at that time, particularly Chris Cole, Jeff Greif and Tim Shaw. Thanks also to Bruce Smith for his 1990 work on <a href="http://reference.wolfram.com/language/ref/Trace.html"><tt>Trace</tt></a> in Wolfram Language, and for encouraging me to think about symbolic representations of computational processes. In much more recent times, I&#8217;d particularly like to thank Jonathan Gorard for his extensive conceptual and practical work on multiway systems and their formalism, both in our Physics Project and beyond. Some of the directions described here have (at least indirectly) been discussed in a number of recent <a href="https://livestreams.stephenwolfram.com/category/live-ceoing/">Wolfram Language design review livestreams</a>, with particular participation by Ian Ford, Nik Murzin, and Christopher Wolfram, as well as Dan Lichtblau and Itai Seggev. Thanks also to <a href="https://www.wolframinstitute.org/">Wolfram Institute</a> fellows Richard Assar and especially Nik Murzin for their help with this piece.</p>
