<p>I'm two-thirds of the way done with my RC batch now.
Eight weeks down, four weeks to go.</p>
<p>The last two weeks have been difficult for me because of life happening.
Week 7 was hard because I had some travel to help my parents, and that just takes me out of my routine and is generally stressful.
It was good, and I am very glad that I had the opportunity to help.
But it was still a lot, and it made it hard to make significant progress on my project.
And week 8 was hard because I finally caught the cold that's been going through my household.
My brain was just... fuzzy this week.</p>
<p>In that vein, I spent the last two weeks mostly focused on figuring out how to build an inverted index over all the unique positions in a collection of chess games I have.
To make it concrete, this is 3.8 million games and about 240 million unique positions (north of 300 million before dedup).
I ran in circles, and I think it was a combination of:</p>
<ul>
<li>Life happened so I wasn't at my best</li>
<li>Databases are hard</li>
</ul>
<p>I'm not upset, though!
By trying a lot of dead-ends, I got to understand the problem space more deeply.
For example, I learned that:</p>
<ul>
<li>Chess positions cannot be represented in a fixed-size struct of less than ~29 bytes<sup class="footnote-reference"><a href="#1">1</a></sup> (and that is a <em>maybe</em>)</li>
<li>Rust's HashMap implementation is based on a hashmap created at Google (<a href="https://www.youtube.com/watch?app=desktop&amp;v=ncHmEUmJZf4">video</a> explaining how it works)</li>
<li><a href="https://vimeo.com/649009599">Data-oriented design</a> gives many practical benefits in structuring data to reduce overhead, such as storing a struct of lists instead of a list of structs</li>
<li>64-bit hashes can handle a <em>lot</em> of elements (4 billion-ish?) before you expect to see your first collision</li>
</ul>
<p>So after these last two weeks, I've finally gotten the index built!
And it saves it out to the disk, which I can load back in to quickly find the games which contain a given position.
(How quickly is yet to be seenâ€”I'll benchmark it, and have a few ideas for improvements if it's slower than necessary.)</p>
<p>Now I'm moving forward on building an application on top of this index.
I'm going to first make an opening tree explorer, where you can click through from the beginning of a game and see how many games occurred with that position, the results from there, and drill into a (partial) list of the actual games containing that position.
This will require building out a basic frontend (entirely HTML/CSS for now! I don't think this needs much, if any, JS), and it will also require adding some additional basic indexes, like bitmaps of game results.</p>
<p>Next week, I'm hoping to have something that I can demo!
It will be rough-and-ready, but it'll be the start, and then I can spend a few more weeks adding in more interesting query support and more filters on the games.
Long-term, I think that <a href="https://sr.ht/~ntietz/isabella-db/">isabella-db</a> can fill a gap in chess tooling today by making it possible to query for really interesting sequences of positions in games, like where sacrifices occur or where tactics are available.
(This will likely also require integrating with an engine!)</p>
<p>I want to get more folks involved in this project, and the sooner the better.
If you're interested in <strong>being an alpha user</strong> or <strong>helping with the queries and indexing</strong>, please reach out to me by email (or on Zulip, if you're a Recurser).
I'm excited to see what I learn via this project for the rest of my batch, and where it goes after that!</p>
<p>See you all next week!</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This blog post used to say that it couldn't be less than 36 bytes. I think that <em>might</em> be true if you use 1 byte per piece and then bit-pack the rest of the information, but a fellow Recurser and I worked out that it can indeed be smaller. Right now speculatively we think it can get down to 29 bytes, but I'm not about to write an implementation to prove it.</p>
</div>
