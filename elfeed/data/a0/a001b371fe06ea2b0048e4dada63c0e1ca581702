<p>I've been working on writing a <a href="https://yet-another-rust-resource.pages.dev/">Rust training course</a>, and one of the things I struggled with explaining in there was the difference between references and pointers.</p>
<p>Ultimately, the underlying representation is <strong>the same</strong>: both hold an address for some memory.
The difference between them is ultimately in semantics.</p>
<p>References have some <a href="https://doc.rust-lang.org/nomicon/references.html">rules</a> enforced by the compiler.
Specifically, they cannot outlive what they refer to (the &quot;referent&quot;), and mutable references cannot be aliased.
Other than that, references behave a lot like the variables they point to.
They have a type, and you can interact with that type to read it or (with mutable references) modify it.</p>
<p>On the other hand, pointers are semantically more about the address.
This means that when we interact with them, we'll be modifying the address (things like <code>add</code> will do pointer offsets instead of adding to the underlying value).
When we print them, we don't print the underlying valueâ€”in fact, we cannot get to the underlying value at all without the <code>unsafe</code> keyword.
Instead, we print out the address.</p>
<p>We can see this with a simple program.</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">fn main() {
    let x: u32 = 10;
    let ref_x: &amp;u32 = &amp;x;
    let pointer_x: *const u32 = &amp;x;

    println!(&quot;x: {x}&quot;);
    println!(&quot;ref_x: {}&quot;, ref_x);
    println!(&quot;pointer_x: {:?}&quot;, pointer_x);
}
</code></pre>
<p>First, we create an unsigned 32-bit integer and give it a value.
Then we create a reference to the same value, and we'll also create a pointer to it.
And then we try to print this out.</p>
<p>When we execute this, we get this output:</p>
<pre><code>x: 10
ref_x: 10
pointer_x: 0x7ffd046a6444
</code></pre>
<p>When we interact with the variable directly or the reference, we get the underlying value.
But with the pointer, we get the address!</p>
<p>You can still access the underlying values with pointers, but you have to use <code>unsafe</code> to do so.
To see why, we can just try to dereference a raw pointer without <code>unsafe</code> and get an error message:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">error[E0133]: dereference of raw pointer is unsafe and requires unsafe function or block
  --&gt; src&#x2F;main.rs:10:32
   |
10 |     println!(&quot;*pointer_x: {}&quot;, *pointer_x);
   |                                ^^^^^^^^^^ dereference of raw pointer
   |
   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior
   = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)
</code></pre>
<p>The important bit is in the note:</p>
<blockquote>
<p>note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior</p>
</blockquote>
<p>And indeed, if we wrap it in <code>unsafe</code>, it will work:</p>
<pre data-lang="rust" class="language-rust "><code class="language-rust" data-lang="rust">println!(&quot;*pointer_x: {}&quot;, unsafe { *pointer_x } );
</code></pre>
<p>Using references is safe.
The compiler will check that you don't alias the same mutable variable multiple times, ensuring you don't have data races.
It will ensure that any references do not outlive the memory they refer to.
You have to verify all those things yourself with raw pointers, so it's unsafe.</p>
<p>So that's the difference between references and pointers in Rust: <strong>they have the same underlying data, but different constraints and semantics with the compiler</strong>.</p>
