<p>I've been working on <a href="https://github.com/ntietz/patzer">Patzer</a>, a chess engine, during my time at RC.
The first engine-like thing I implemented for it was <a href="https://www.chessprogramming.org/Alpha-Beta">alpha-beta pruning</a>, which is a way of pruning out branches of the search tree to significantly speed up search.
This is a common algorithm, which I also implemented in my undergrad AI class.
That doesn't mean that I fully understood it as I wrote it!
It's pretty tricky in the details and not immediately obvious <em>why</em> the pruning works.</p>
<p>In the process of writing it and debugging it, another Recurser and I traced through the execution with a known position where we could calculate the execution.
This let us figure out what was going wrong, and also gain some intuition for what the algorithm was doing.
I'm going to use that same position here to illustrated alpha-beta pruning.
(This is partially so that when I inevitably forget the details, I can come back here and refresh myself!)</p>
<p>We'll start with an overview of the algorithm viewed through the lens of the algorithm it enhances, minimax.
Then we will look at the alpha-beta pruning algorithm itself.
We'll wrap up by looking at our example position, a hand-constructed position which utilizes a smothered mate, and see how minimax and alpha-beta pruning work on it.</p>
<h1 id="minimax-algorithm">Minimax algorithm</h1>
<p>The base algorithm we're using here is called <a href="https://en.wikipedia.org/wiki/Minimax">Minimax</a>, and the name comes from what you're trying to do:
You want to <em>minimize</em> the cost of the worst case <em>maximum</em> cost.</p>
<p>The intuition here is that under best play, if your opponent is making optimal moves, then they're going to make the moves which put you in the worst possible position.
You're trying to pick moves which make your worst case less bad.
(And that's ultimately what playing good chess is about: not making mistakes, and taking advantage of your opponent's mistakes.)</p>
<p>Here's Python-esque pseudocode which we could use for a basic Minimax implementation:</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python">def max_step(board, depth):
  if depth == 0:
    return score(board)

  max_score = INT_MIN;

  for move in board.moves():
    next_position = board.make_move(move)
    score = min_step(next_position, depth - 1)
    if score &gt; max_score:
      max_score = score

  return max_score


def min_step(board, depth):
  if depth == 0:
    return -1 * score(board)

  min_score = INT_MAX

  for move in board.moves():
    next_position = board.make_move(move)
    score = max_step(next_position, depth - 1)
    if score &lt; min_score:
      min_score = score

  return min_score
</code></pre>
<p>The <code>max_step</code> function is the one that corresponds to the current player:
They're trying to maximize among their possible outcomes.
The <code>min_step</code> function corresponds to the opponent, who is trying to minimize
their opponent's best case.</p>
<p>(As an aside: this is usually written in the <a href="https://www.chessprogramming.org/Negamax">Negamax</a> style, which reduces it down to one function.
This is how I've implemented it in Patzer, but for clarity I'm presenting it as two separate functions.)</p>
<p>This algorithm will find all the best moves!
Unfortunately, it's also slow.
It exhaustively explores the entire state space of the game tree.
For chess, this gets quite large quite quickly:
There are over 6 trillion leaves in the minimax tree after the first 4 complete moves of the game (depth 8).
My computer would not ever reach this depth.</p>
<p>So, what are we to do?</p>
<h1 id="alpha-beta-pruning">Alpha-beta pruning</h1>
<p>This is where alpha-beta pruning comes in.
It's an optimization for minimax which allows us to prune out major swaths of the search tree.</p>
<p>The core idea of alpha-beta pruning is that there are some branches we know we won't explore, because they're too good or too bad.
If a branch has a way that we can guarantee a better outcome than another branch, our opponent won't let us pursue that.
If a branch has a way that our opponent can guarantee us a worse outcome than another branch, we won't go down that one, either.</p>
<p>To make this work, we keep track of the lower-bound (alpha) and upper-bound (beta), which let us then eliminate branches once we've confirmed that the branch will violate one of the bounds that we can otherwise guarantee.
Note that this is done depth-first, like minimax.
This is crucial for finding a leaf quickly to evaluate.</p>
<p>Here's the pseudocode of the algorithm.
Again, this is the two-function implementation; you can make it one function at the expense of some readability.
I've put some inline comments to highlight the differences between this and minimax.
These comments are only in the max step function, but apply equally to both.</p>
<pre data-lang="python" class="language-python "><code class="language-python" data-lang="python"># we add two parameters, alpha and beta, which track lower and upper bounds
def alphabeta_max_step(alpha, beta, board, depth):
  if depth == 0:
    return score(board)

  # note that we&#x27;re not tracking the max or min anymore!
  # these are tracked via alpha and beta now.

  for move in board.moves():
    next_position = board.make_move(move)
    score = alphabeta_min_step(alpha, beta, next_position, depth - 1)

    # when the score is higher than the upper bound, we just fail to the
    # already established upper bound.
    if score &gt;= beta:
      return beta

    # when we find a score that&#x27;s higher than alpha, our lower bound, we
    # can adopt it as the new lower bound since we know we can achieve
    if score &gt; alpha:
      alpha = score

  return alpha


def alphabeta_min_step(alpha, beta, board, depth):
  if depth == 0:
    return -1 * score(board)

  for move in board.moves():
    next_position = board.make_move(move)
    score = alphabeta_max_step(alpha, beta, next_position, depth - 1)

    if score &lt;= alpha:
      return alpha

    if score &lt; beta:
      beta = score

  return min_score
</code></pre>
<p>Using these bounds turns out to be very helpful.
Analysis on <a href="https://www.chessprogramming.org/Alpha-Beta">Chess Programming Wiki</a> indicates that this can cut down the search tree significantly.
If we always get the best move first, we would only have to evaluate 5 million positions.
Obviously we can't know what the best move is or we would just play it!
But there are ways we can order moves to find the best move earlier, and if you order them randomly you will still prune significantly.</p>
<h1 id="alpha-beta-pruning-illustrated">Alpha-Beta Pruning Illustrated</h1>
<p>Alpha-beta pruning is pretty dense and hard for me to understand without tracing through a position in a game tree, so let's use an example to do that.</p>
<p>Here is our starting position, with white to move.</p>
<div id="chess-container" style="width: 400px"></div>
<p>This position is set up for a classic checkmate known as the <a href="https://en.wikipedia.org/wiki/Smothered_mate">smothered mate</a>.
From here, it's forced mate in two if white finds the right moves.
We chose this position as our starting position since there is a clear tactical solution which is easy to evaluate as a human, and because it's a treacherous position:
If you make the <em>wrong</em> move, black has checkmate available as well.</p>
<p>We're going to look at a dramatically simplified game tree, too, to illustrate the algorithm.
For this illustration, we are just considering three branches (moves are numbered starting from 1 for clarity):</p>
<ol>
<li><strong>The smothered mate line.</strong> 1. Qg8+ Rxg8 2. Nf7#</li>
<li><strong>The &quot;whoops I lost&quot; line.</strong> 1. Qb7 Rc1#</li>
<li><strong>The pawn line.</strong> 1. h3 h6 (Now no one has back rank mate) 2. h4 h5</li>
</ol>
<p>We'll look at each of these first moves by white, followed by black's possible follow-ups, to a maximum depth of 4.</p>
<p>Here's our game tree, where we're examining at most 2 branches each time, except the root:</p>
<!--
@startmindmap initialGameTree

*:root
a=-200
b=200;
** Qb7
*** Rc1#
*** Rf8
**** Qg8+
**** Qh3
** h3
*** h6
**** Qe6
**** h4
*** Rc1+
**** Qd1
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3

@endmindmap
-->
<p><img src="/images/diagrams/initialGameTree.png" alt="" /></p>
<p>This is as dramatically reduced game tree, and it's already fairly overwhelming!</p>
<p>(If you're not used to the notation and you're wondering what things like &quot;Qg8+&quot; mean, this is <a href="https://en.wikipedia.org/wiki/Algebraic_notation_(chess)">algebraic notation</a>. It's not the most intuitive, but it's standard, so I think most chess players will be able to read it.)</p>
<p>If we look through this with minimax, we'll find one forced mate!
There's another one hiding out, but it's not in our tree here, so we wouldn't find it.
Since this move tree is for the player to move, the first and third layers are what we are looking at.
If we find a checkmate there, great!
The second layer is what our opponent is looking at, and if they find a checkmate there, boo, bad for us.</p>
<p>With minimax, we'd evaluate 9 leaf nodes.</p>
<p>Now let's consider what we'd be able to do with alpha-beta pruning.
Assume we start by evaluating the Qb7 line.
Then we see our opponent is able to make the move Rc1#, and that results in checkmate!
This means we don't have to evaluate any further down that move tree.</p>
<!--
@startmindmap ab1

*[#lightgreen]:root
a=-200
b=200;
**[#lightgreen]:Qb7
a=-200
b=200;
***[#lightgreen]:Rc1#
score=-200;
*** Rf8
**** Qg8+
**** Qh3
** h3
*** h6
**** Qe6
**** h4
*** Rc1+
**** Qd1
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3

@endmindmap
-->
<p><img src="/images/diagrams/ab1.png" alt="" /></p>
<p>We score a checkmate for ourselves as 200 points, and a checkmate for our opponent as -200.</p>
<p>So after we evaluate the Rc1# position as -200, that hits our <code>score &lt;= alpha</code> case for our opponent (<code>alphabeta_min_step</code>).
This returns early, and our opponent prunes out the rest of that tree, since we know that there won't be anything better than a win for our opponent.
We've gotten our first pruning!</p>
<!--
@startmindmap ab2

*[#lightgreen]:root
a=-200
b=200;
**[#lightblue]:Qb7
a=-200
b=200;
***[#lightblue]:Rc1#
score=-200;
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
** h3
*** h6
**** Qe6
**** h4
*** Rc1+
**** Qd1
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab2.png" alt="" /></p>
<p>This has resulted in <strong>no change</strong> to our alpha and beta values.</p>
<p>Now we happen to pick <code>h3</code> as our next move.
We go down one line, and end up evaluating the final position as +10 (we have 17 points of material to our opponent's 7).</p>
<!--
@startmindmap ab3

*[#lightgreen]:root
a=-200
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightgreen]:h3
a=-200
b=200;
***[#lightgreen]:h6
a=-200
b=200;
****[#lightgreen]:Qe6
score=10;
****[#lightgreen]:h4
score=10;
*** Rc1+
**** Qd1
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab3.png" alt="" /></p>
<p>Unfortunately, this doesn't result in any pruning, but it does change the alpha and beta values.</p>
<!--
@startmindmap ab4

*[#lightgreen]:root
a=-200
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightgreen]:h3
a=-200
b=10;
***[#lightblue]:h6
a=10
b=200;
****[#lightblue]:Qe6
score=10;
****[#lightblue]:h4
score=10;
*** Rc1+
**** Qd1
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab4.png" alt="" /></p>
<p>We finish out this branch and have a final score for it of 10.</p>
<!--
@startmindmap ab5

*[#lightgreen]:root
a=-200
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightgreen]:h3
a=-200
b=10;
***[#lightblue]:h6
a=10
b=200;
****[#lightblue]:Qe6
score=10;
****[#lightblue]:h4
score=10;
***[#lightgreen]:Rc1+
a=-200
b=10;
****[#lightgreen]:Qd1
score=10;
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab5.png" alt="" /></p>
<!--
@startmindmap ab6

*[#lightgreen]:root
a=-200
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightgreen]:h3
a=10
b=10;
***[#lightblue]:h6
a=10
b=200;
****[#lightblue]:Qe6
score=10;
****[#lightblue]:h4
score=10;
***[#lightblue]:Rc1+
a=10
b=10;
****[#lightblue]:Qd1
score=10;
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab6.png" alt="" /></p>
<p>Here we can see that alpha and beta have both gone to 10, so even if we had a third branch to explore after h3, we'd know the score <em>must</em> be 10, because the upper and lower bounds have converged!
This gives white the ability to guarantee at least 10 points, so alpha changes to that at the root. It's our lower bound.</p>
<p>Note: there is a line in there which at depth 4 does result in checkmate for our opponent. We didn't see it. This is one of the perils of evaluating to a particular depth, and there are techniques like <a href="https://www.chessprogramming.org/Quiescence_Search">quiescence search</a> which mitigate this.
But we'll just pretend it isn't an issue here, and move on!</p>
<!--
@startmindmap ab7

*[#lightgreen]:root
a=10
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightblue] h3
***[#lightblue] h6
****[#lightblue] Qe6
****[#lightblue] h4
***[#lightblue] Rc1+
****[#lightblue] Qd1
** Qg8+
*** Rxg8
**** Nf7#
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab7.png" alt="" /></p>
<p>Now we make our move, and our opponent's reply is forced.
If we happen to then also pick the right final move first, we prune out all the remaining ones.</p>
<!--
@startmindmap ab8

*[#lightgreen]:root
a=10
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightblue] h3
***[#lightblue] h6
****[#lightblue] Qe6
****[#lightblue] h4
***[#lightblue] Rc1+
****[#lightblue] Qd1
**[#lightgreen]:Qg8+
a=10
b=200;
***[#lightgreen]:Rxg8
a=10
b=200;
****[#lightgreen]:Nf7#
score=200;
**** Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab8.png" alt="" /></p>
<p>Working our way back up the search tree, we can see the effects on alpha and beta.</p>
<!--
@startmindmap ab9

*[#lightgreen]:root
a=10
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightblue] h3
***[#lightblue] h6
****[#lightblue] Qe6
****[#lightblue] h4
***[#lightblue] Rc1+
****[#lightblue] Qd1
**[#lightgreen]:Qg8+
a=10
b=200;
***[#lightgreen]:Rxg8
a=200
b=200;
****[#lightblue] Nf7#
****[#darkgrey] Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab9.png" alt="" /></p>
<p>Once again we've found a situation where alpha = beta, so we can prune the rest of that tree.
As we work our way back up, we eventually find that this is, indeed, the best move.</p>
<!--
@startmindmap ab10

*[#lightgreen]:root
a=200
b=200;
**[#lightblue] Qb7
***[#lightblue] Rc1#
***[#darkgrey] Rf8
****[#darkgrey] Qg8+
****[#darkgrey] Qh3
**[#lightblue] h3
***[#lightblue] h6
****[#lightblue] Qe6
****[#lightblue] h4
***[#lightblue] Rc1+
****[#lightblue] Qd1
**[#lightblue] Qg8+
***[#lightblue] Rxg8
****[#lightblue] Nf7#
****[#darkgrey] Nd3
@endmindmap
-->
<p><img src="/images/diagrams/ab10.png" alt="" /></p>
<p>The evaluation for this position is, correctly, that white is going to win.</p>
<p>And the best part: with alpha-beta pruning, we only had to evaluate 4 leaf nodes, instead of 7!</p>
<h1 id="i-think-i-get-it-now">I think I get it now!</h1>
<p>This exercise was helpful for me in internalizing how alpha-beta pruning works.
The fundamentals are pretty clear:</p>
<ul>
<li>At every round, you pick the move that maximizes your lower bound</li>
<li>At every round, your opponent picks the move that minimizes your upper bound</li>
</ul>
<p>Alpha is your lower bound, and beta is your upper bound.</p>
<p>Overall I get the algorithm better than I did before.
It's still difficult for me to visualize and keep in my head, especially in the negamax form.
Someday, I might make an interactive visualization for it, but not today!</p>
<p>One big takeaway from this is that alpha-beta pruning is making the same tradeoff we make in many systems:
Increasing speed and efficiency at the cost of understandability.
Most times when you optimize a program, unless you're swapping in a fundamentally more elegant solution, that optimization makes it harder to understand.</p>
<p>This isn't without risks!
When it's harder to understand, it's easier to make mistakes and introduce bugs.
We had a lot of bugs while implementing alpha-beta pruning the first time, and had to trace through it by hand.
Having an easy visualizer for the search tree would have been helpful, but also has its limits:
The whole search tree would be overwhelmingly large, and the parts that are helpful to trace are hard to pick without a human in the loop.</p>
<p>If anyone has good ideas on how to present the search tree to human users, I'd be all ears!
I'd like Patzer to be at least somewhat comprehensible, and having nice visualizations on it would be a pretty cool angle on that.</p>
<div>
  <script src="/js/jquery-3.5.1.min.js"></script>
  <script src="/js/chessboard-1.0.0.min.js"></script>
  <link rel="stylesheet" href="/js/chessboard-1.0.0.min.css" />
  <script src="/js/blog/alphabeta.js"></script>
</div>
