<p>While reading <a href="https://www.manning.com/books/real-world-cryptography">Real-World Cryptography</a>, I came across the <a href="https://en.wikipedia.org/wiki/Adaptive_chosen-ciphertext_attack">&quot;million message attack&quot;</a>.
This is an attack that Daniel Bleichenbacher demonstrated in 1998, which effectively broke RSA with a particular encoding function called <a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS #1</a>.
It was only mentioned briefly, so I dug in and decided to try to understand the attack, eventually to implement it.</p>
<p>Most crypto libraries do not ship with a vulnerable implementation of this, for good reason.
It's been broken!
And if I implement the full attack against a real implementation, it would also come with using realistic key size.</p>
<p>Instead, I decided to implement RSA myself so that I could implement a weak encoding scheme so I could implement the Bleichenbacher attack!
So far, I have an implementation of RSA and of PKCS (the vulnerable one).
The basics of RSA took an hour to implement, then what felt like days to debug. And now it (seemingly) works!
The attack will follow soon, with any luck.</p>
<h1 id="what-s-rsa-anyway">What's RSA, anyway?</h1>
<p>RSA is a public-key cryptosystem, in contrast to symmetric key cryptosystems.
With symmetric keys, the sender and the recipient both share a key and use the same key to encrypt and decrypt the message.
In contrast, public-key cryptosystems have a key <em>pair</em>, a public and a private key.
The public key can be used to <em>encrypt</em> messages and the private key to <em>decrypt</em> them<sup class="footnote-reference"><a href="#also-sigs">1</a></sup>.</p>
<p>One of the drawbacks of a symmetric key system is that you have to share the key.
This means you have to use a <em>different</em> secure channel to transmit the key, and then both parties need to be really careful to keep it a secret.
This isn't manageable for a system with a lot of participants, like the internet!</p>
<p>But symmetric key encryption is often <em>very fast</em>, and we have some of the operations for it even <a href="https://en.wikipedia.org/wiki/AES_instruction_set">baked into hardware</a>.
It would be nice to use it where we can for that efficiency.</p>
<p>In contrast, with public-key cryptography, you can freely share the public key, and anyone can then use that to encrypt a message to you.
This means you do not need a separate secure channel to share the key!
(Although this ignores the whole problem of validating that the key comes from the right person, so you're not having your connection spoofed by an interloper.)
And this is great!
This is what RSA gives us, but the computations for RSA are slow and the messages you can send are also small.</p>
<p>In practice, RSA was used (regrettably, sometimes still is) to establish a secure connection and perform a key exchange, and then the keys you exchange let you use symmetric key encryption.
You probably <a href="https://blog.trailofbits.com/2019/07/08/fuck-rsa/">shouldn't use RSA</a>.
Modern alternatives exist that are better, like Curve25519 and other forms of elliptic-curve cryptography.</p>
<p>But for worse, we run into RSA, and it's also a fun historical artifact!
It's worth understanding in, and hey, implementing it is just plain fun.</p>
<h1 id="the-basics-of-rsa">The basics of RSA</h1>
<p><a href="https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29">RSA</a> is a nicely elegant cryptosystem.
Its security is based on the difficulty of factoring the product of large prime numbers, and in its purest form it has no known breaks<sup class="footnote-reference"><a href="#quantum-tho">2</a></sup>.
However, as mentioned above, depending on how data is encoded, particular uses of it <em>can</em> be broken.</p>
<p>The basic operations of it are straightforward to express.
There are three components:</p>
<ol>
<li>Generating keys</li>
<li>Encrypting and decrypting!</li>
<li>Encoding messages</li>
</ol>
<p>We'll go through each of those, starting with generating keys.</p>
<h2 id="generating-your-keys">Generating your keys</h2>
<p>First of all, what even is a key?
We know that it's used to encrypt or decrypt a message, but what is inside it?</p>
<p>For RSA, a key comprises two numbers.
One of these is called the <strong>exponent</strong> and one is the <strong>modulus</strong>.
A key could be <strong>(exp=3, mod=3233)</strong>, for example.
It's really just this pair of numbers<sup class="footnote-reference"><a href="#metadata">3</a></sup>.</p>
<p>The reason the pieces of it are called the exponent and modulus is because of how we use them!
RSA relies on <a href="https://en.wikipedia.org/wiki/Modular_arithmetic">modular arithmetic</a> (like clock math, if you're not familiar).
These are the exponents and modulus for the encryption or decryption operations which we'll see later.</p>
<p>To generate a key, you follow a short procedure.</p>
<ol>
<li>First, pick two prime numbers which we'll call <strong>p</strong> and <strong>q</strong>. Then we compute <strong>n = p * q</strong>.</li>
<li>Compute a number <strong>t = lcm(p-1, q-1)</strong>. This is the <a href="https://en.wikipedia.org/wiki/Carmichael_function">totient</a>, and we use this as our modulus for generating the keys but then never again.</li>
<li>Pick the public exponent, which we'll call <strong>e</strong>. The requirement is that it shares no factors with <strong>t</strong> and is greater than 2. One simple way is to start with 3, but go up through the primes until you find one coprime with <strong>t</strong>. Choosing 65537 is also quite common, since it's small enough to be efficient for encryption but large enough to avoid some particular attacks.</li>
<li>Calculate the private exponent, which we'll call <strong>d</strong>. We compute this as <strong>d = e^-1 mod t</strong>, or the inverse of <strong>e</strong> in our modulus.</li>
</ol>
<p>Now you have <strong>d</strong> and <strong>e</strong>, the private and public exponents, and you have <strong>n</strong>, the modulus.
Bundle those up into two tuples and you have your keys!</p>
<p>Let's work an example quickly to see how it ends up.
For our primes, we can choose <strong>p = 17</strong> and <strong>q = 29</strong>.
So then <strong>n = 493</strong>.</p>
<p>Now we find <strong>t = lcm(17 - 1, 29 - 1) = lcm(16, 28) = 112</strong>.
We'll choose <strong>e = 3</strong>, which works since <strong>2 &lt; 3</strong> and <strong>gcd(3, 112) = 1</strong> so we know they share no factors.
Now we compute<sup class="footnote-reference"><a href="#wolfram-alpha">4</a></sup> <strong>d = e^-1 = 3^-1 = 75 mod 112</strong>.
And then we have our keys!</p>
<p>Our public key is <strong>(exp=3, mod=493)</strong>, and our private key is <strong>(exp=75, mod=493)</strong>.
We'll use these again in our examples on encrypting and decrypting!</p>
<h2 id="encrypting-and-decrypting-a-message">Encrypting and decrypting a message</h2>
<p>Now that we have our keys, we can encrypt and decrypt a message!
Normally, we would think of a message as something like &quot;hello, world&quot; but to RSA, every message is a single integer.
Let's assume for now that we're okay with this, but we'll come back to how we get from a message to an integer later.</p>
<p>Our message integer has to be less than our modulus, otherwise we can't decrypt it, since you'll never get back something <em>larger</em> than the modulus in modular arithmetic.
Let's call that message <strong>m</strong>.</p>
<p>To encrypt the message, we take our exponent <em>e</em> and modulus <em>n</em> from the public key and we compute the ciphertext <strong>c = m^e mod n</strong>.
This gives us back <em>another</em> integer, which we can send to the recipient!</p>
<p>For them to decrypt it, they use the exponent <em>d</em> and the same modulus <em>n</em> from the private key, and compute the plaintext as <strong>m = c^d = (m^e)^d mod n</strong>.
This works out and the exponents essentially cancel out (we're hand waving, but trust meâ€”or at least trust Rivest, Shamir, and Adleman).</p>
<p>As an example, let's encrypt something and decrypt it again.
Let's say our message is <strong>m = 42</strong>, for <a href="https://en.wikipedia.org/wiki/Phrases_from_The_Hitchhiker%27s_Guide_to_the_Galaxy#The_Answer_to_the_Ultimate_Question_of_Life,_the_Universe,_and_Everything_is_42">arbitrary reasons</a>.
To encrypt it using our keys from earlier, we compute <strong>c = m^e = 42^3 = 138 mod 493</strong>.
And to decrypt our ciphertext, we compute <strong>m = c^d = 138^75 = 42 mod 493</strong>.</p>
<p>That's it as far as encrypting and decrypting goes!
It's elegant, and deceptively simple: this simplicity is why so many people implement their own versions of RSA and roll their own crypto vulnerabilities.
Don't do it for anything that matters!
But <em>do</em> roll your own for the fun of it.</p>
<h2 id="how-do-you-encode-messages">How do you encode messages?</h2>
<p>Okay, so how do we get from a string of characters, like &quot;hello, world&quot;, to an integer?
We encode it!
And if the message is too large to fit in one integer, we can split it into multiple integers and encrypt each of them.</p>
<p>Everything in a memory in a computer is just bytes.
You have a string of characters, and underlying that is a byte array.
You have an integer, and underlying that are some bytes!
This is how we're going to go between them.</p>
<p>Let's assume for simplicity that we're using 64-bit integers.
Then each integer is 8 bytes.
In our message &quot;hello, world&quot;, we have 12 bytes!</p>
<p><img src="/images/rsa/diagram1.svg" alt="An array representation of each char in &quot;hello, world&quot;" /></p>
<p>Each character has a byte value.
Here, we're assuming it's ASCII encoded for simplicity.
This converts nicely into an array of 8-bit integers, or single bytes.</p>
<p><img src="/images/rsa/diagram2.svg" alt="Decimal values of each byte in &quot;hello, world&quot; as an array" /></p>
<p>And now we can turn this into two byte arrays of length 8.
The first 8 bytes become one array, and the last 4 bytes become the second one.
We can left-pad it with 0s, but we could also right pad if we prefer; either way we have to pad, and then we have to remember to stick with the same big-endian or little-endian encoding.</p>
<p><img src="/images/rsa/diagram3.svg" alt="Two 8-byte arrays containing the values of &quot;hello, w&quot; and &quot;orld&quot; (with left-padded 0s)" /></p>
<p>Now since these are 8 bytes each, we can use them as the memory for a 64-bit integer!
They are 7522537965569712247 and 1869769828, respectively.
You can encrypt each of these (given a key that has a high enough modulus), and then you're in business!</p>
<p>In practice, you want to use one of the other encoding schemes.
<a href="https://en.wikipedia.org/wiki/PKCS_1">PKCS #1</a> was popular for a while, but has some flaws.
Notably, this made problems for some versions of SSL.
There are improvements to PKCS now, but it's still not something you should use since that would mean you're using RSA!
(Yes, I'm going to keep reminding all of us to not use RSA.)</p>
<h1 id="lessons-learned">Lessons learned</h1>
<p>I learned a lot in the process of implementing RSA here.
Here are a few of the key things, in kind of a scattered list.</p>
<ul>
<li><strong>Implementing cryptosystems is fun.</strong> This was one of my biggest takeaways. One time I got to chop down a tree and it was <em>exactly</em> as fun as I imagined it would be. This was the same: I'd long imagined how satisfying it would be but was intimidated, and diving in let me understand that this isn't so scary, and it's a lot of fun.</li>
<li><strong>There are a lot of subtle ways to be vulnerable.</strong> We use libraries with constant-time operations to avoid timing attacks. Bleichenbacher's whole attack relies on being able to detect if encoding is incorrect, so any subtle signal of where the decryption fails is useful for this. There are myriad other ways to be vulnerable. This reminds me why we need to rely on deep expertise in cryptography, rather than go around implementing these ourselves.</li>
<li><strong>Big-endian vs. little-endian <em>still</em> trips me up.</strong> I can never remember which is which, so I really desperately need to write a blog post about it as my own reference.</li>
<li><strong>Debugging this is tricky!</strong> In particular, I'd originally missed the requirement that the message was less than the modulus, and ended up having sporadic failures depending on the primes chosen and the message. That made for tough debugging, but setting constant small <em>p</em> and <em>q</em> helped. There were a few other tough instances of debugging, and I expect there are some issues that remain!</li>
<li><strong>Security properties can be at odds with ergonomics.</strong> The <a href="https://crates.io/crates/crypto-bigint">bigint library</a> I'm using has a lot of properties you want: constant-time operations, checked or wrapping operations, good efficiency. But it's also sometimes hard to read code written with it, since you have to be fairly explicit about the operations you're using. There are some improvements to be made, but it feels like there's an inherent tension here.</li>
<li><strong>Reading RFCs and some cryptography papers is... accessible?</strong> I was surprised when I read the Bleichenbacher paper and felt like it was pretty easy to read. I have a math degree, but not much background in cryptography (and a decade between me and a math classroom), so this was very encouraging! The RFC for PKCS was also readable, which was nice to find out.</li>
</ul>
<h1 id="what-s-next">What's next</h1>
<p>Now I have a toy implementation of RSA and PKCS, so it's time to do what I came here for: break the thing.
The toy implementation is <a href="https://crates.io/crates/cryptoy">published on crates.io</a>, and the <a href="https://git.sr.ht/~ntietz/cryptoy">source is available</a>.
In a future blog post, I'll talk about how the attack works and provide a demo.</p>
<p>I might also take a swing at some of the other classic cryptosystems.
The Diffie-Hellman key exchange is calling out to me, for example.</p>
<p>If you've implemented a cryptosystem just for fun, I'd <a href="mailto:me@ntietz.com">love to see it</a>.</p>
<hr />
<div class="footnote-definition" id="also-sigs"><sup class="footnote-definition-label">1</sup>
<p>You can also use the private key to generate a signature which can be validated with the public key!</p>
</div>
<div class="footnote-definition" id="quantum-tho"><sup class="footnote-definition-label">2</sup>
<p>Except with quantum computers, but you know... we've got a few years. That's what they tell us, anyway.</p>
</div>
<div class="footnote-definition" id="metadata"><sup class="footnote-definition-label">3</sup>
<p>You may also have metadata that's distributed with the key to indicate other information like what cryptosystem is used, the size of the key, encodings, etc.</p>
</div>
<div class="footnote-definition" id="wolfram-alpha"><sup class="footnote-definition-label">4</sup>
<p>I used <a href="https://www.wolframalpha.com/input?i=3%5E-1+mod+112">Wolfram Alpha</a> to compute this, but there are <a href="https://en.wikipedia.org/wiki/Modular_multiplicative_inverse#Computation">many algorithms</a> to compute it.</p>
</div>
