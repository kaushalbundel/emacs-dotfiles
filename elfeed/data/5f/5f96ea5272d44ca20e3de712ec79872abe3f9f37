<p>I made up a neat little pattern in Go the other day. It’s a way to represent a state change in a system by exposingdifferent APIs for different states, while only holding state in a single underlying struct. I’m sure I’m not the firstperson to invent this, and it may already a name, so please let me know if you know of one <em>[Update:<a href="https://lobste.rs/~apg">apg</a> on Lobsters <a href="https://lobste.rs/s/tzgizl/representing_state_as_interfaces_go#c_cvlm2d">pointed out thename</a> “typestate”, which I like]</em>.  I’m goingto show an instance of the pattern first and the motivation after.</p><h2 id="the-pattern">The Pattern</h2><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// You start with a Resolver, and incrementally feed it data to be looked up</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Resolver</span> <span class="kd">interface</span> <span class="p">{</span></span></span><span class="line"><span class="cl">    <span class="c1">// Collect collects some piece of data and maybe extra information about it that you</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// need to do resolution</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Collect</span><span class="p">(</span><span class="nx">someId</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">someData</span> <span class="kt">string</span><span class="p">)</span></span></span><span class="line"><span class="cl">    <span class="c1">// Maybe you also need some global contextual data to do the resolve</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">AddContextualData</span><span class="p">(</span><span class="nx">data</span> <span class="nx">SomeContext</span><span class="p">)</span></span></span><span class="line"><span class="cl">    <span class="c1">// When you're done, the resolve can send the bulk query to the executor to perform</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// the lookup that you want to do</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Execute</span><span class="p">(</span><span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">Executor</span><span class="p">)</span> <span class="p">(</span><span class="nx">Resolved</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="c1">// Resolved is what you get back after you Execute, and it lets you access the resolved data</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Resolved</span> <span class="kd">interface</span> <span class="p">{</span></span></span><span class="line"><span class="cl">    <span class="c1">// Resolve returns the result. If the result doesn't have that id, either because it</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// wasn't looked up successfully during execution or because you never [Collect]ed it,</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// it will return ("", false)</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">Resolve</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="c1">// Executor is capable of doing the db lookup/cache lookup/service request/http request</span></span></span><span class="line"><span class="cl"><span class="c1">// that actually gets the data you need to get</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">Executor</span> <span class="kd">interface</span> <span class="p">{</span></span></span><span class="line"><span class="cl">    <span class="nf">DoTheThing</span><span class="p">(</span></span></span><span class="line"><span class="cl">        <span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span></span></span><span class="line"><span class="cl">        <span class="nx">idsToResolve</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span><span class="p">,</span></span></span><span class="line"><span class="cl">        <span class="nx">contextualData</span> <span class="nx">SomeContext</span><span class="p">,</span></span></span><span class="line"><span class="cl">    <span class="p">)</span> <span class="p">([]</span><span class="nx">ResolveResult</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>So far, so boring.  You’ve got a <code>Resolver</code> that batches up query data, an <code>Executor</code> that, well, executes the query,and a <code>Resolve</code> that lets you access the result.  What’s neat about this is that <code>Resolver</code> and <code>Resolved</code> can beimplemented by the same struct:</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">idResolver</span> <span class="kd">struct</span> <span class="p">{</span></span></span><span class="line"><span class="cl"><span class="nx">collected</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">string</span></span></span><span class="line"><span class="cl"><span class="nx">contextData</span> <span class="nx">SomeContext</span></span></span><span class="line"><span class="cl"><span class="nx">resolved</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">string</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">idResolver</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">someId</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">someCategory</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span></span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">collected</span><span class="p">[</span><span class="nx">someCategory</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">collected</span><span class="p">[</span><span class="nx">someCategory</span><span class="p">],</span> <span class="nx">someId</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">idResolver</span><span class="p">)</span> <span class="nf">AddContextualData</span><span class="p">(</span><span class="nx">data</span> <span class="nx">SomeContext</span><span class="p">)</span> <span class="p">{</span></span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">contextData</span> <span class="p">=</span> <span class="nx">data</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">idResolver</span><span class="p">)</span> <span class="nf">Execute</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">executor</span> <span class="nx">Executor</span><span class="p">)</span> <span class="p">(</span><span class="nx">Resolved</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span></span></span><span class="line"><span class="cl"><span class="nx">result</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">executor</span><span class="p">.</span><span class="nf">DoTheThing</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">collected</span><span class="p">,</span> <span class="nx">r</span><span class="p">.</span><span class="nx">contextData</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span></span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">err</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">resolved</span> <span class="p">=</span> <span class="nf">transformResult</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="cm">/***</span></span></span><span class="line"><span class="cl"><span class="cm"> * 🪄 THE MAGIC 🪄</span></span></span><span class="line"><span class="cl"><span class="cm"> * Ooh look I'm just returning this struct as a Resolved!</span></span></span><span class="line"><span class="cl"><span class="cm"> */</span></span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">r</span><span class="p">,</span> <span class="kc">nil</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">idResolver</span><span class="p">)</span> <span class="nf">Resolve</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span></span></span><span class="line"><span class="cl"><span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">resolved</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span></span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><h2 id="ok-but-why">Ok but why?</h2><p>I was building a system to bulk-lookup names in my system by ID.  But if you called <code>Resolve</code> before it had executed,you’d have an invalid result.  And if you <code>Collected</code> after you executed, you’d never look up the id.  So I added aboolean <code>hasExecuted</code> to <code>IdResolver</code> so that if you called <code>Resolve</code> before you had called <code>Execute</code> or <code>Collect</code>after, it would check that flag and panic.</p><div class="highlight"><pre class="chroma" tabindex="0"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">StatefulIdResolver</span><span class="p">)</span> <span class="nf">Collect</span><span class="p">(</span><span class="nx">someId</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">someCategory</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span></span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">hasExecuted</span> <span class="p">{</span></span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="s">"Collect called after Execute"</span><span class="p">)</span></span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span><span class="line"><span class="cl"><span class="nx">r</span><span class="p">.</span><span class="nx">collected</span><span class="p">[</span><span class="nx">someCategory</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">r</span><span class="p">.</span><span class="nx">collected</span><span class="p">[</span><span class="nx">someCategory</span><span class="p">],</span> <span class="nx">someId</span><span class="p">)</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="c1">// Execute executes and changes state but doesn't return anything new</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">StatefulIdResolver</span><span class="p">)</span> <span class="nf">Execute</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">executor</span> <span class="nx">Executor</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span></span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">r</span><span class="p">.</span><span class="nx">hasExecuted</span> <span class="p">{</span></span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="s">"Execute called twice"</span><span class="p">)</span></span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span><span class="line"><span class="cl">    <span class="o">...</span></span></span><span class="line"><span class="cl">    <span class="nx">r</span><span class="p">.</span><span class="nx">hasExecuted</span> <span class="p">=</span> <span class="kc">true</span></span></span><span class="line"><span class="cl">    <span class="o">...</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span><span class="line"><span class="cl"></span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">r</span> <span class="o">*</span><span class="nx">StatefulIdResolver</span><span class="p">)</span> <span class="nf">Resolve</span><span class="p">(</span><span class="nx">id</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span></span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">!</span><span class="nx">r</span><span class="p">.</span><span class="nx">hasExecuted</span> <span class="p">{</span></span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span><span class="s">"Resolve called before execute"</span><span class="p">)</span></span></span><span class="line"><span class="cl">    <span class="p">}</span></span></span><span class="line"><span class="cl"><span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">r</span><span class="p">.</span><span class="nx">resolved</span><span class="p">[</span><span class="nx">id</span><span class="p">]</span></span></span><span class="line"><span class="cl"><span class="k">return</span> <span class="nx">res</span><span class="p">,</span> <span class="nx">ok</span></span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div><p>This is kind of a mess, harder to read and maintain, and much easier to mess up the logic in.</p><h2 id="when-to-use-it">When to use it</h2><p>Of course the <code>Resolver</code> and the <code>Resolved</code> <em>could</em> be represented by different structs with their own methods.  But inthis case it felt like we were really working with a single object:  it collects data, operates on it, and manages theresult.</p><p>The crux of the matter is that the object has different operations that are valid in different states, and Go interfacesare a perfect way to expose that.</p><h2 id="update-is-this-just-a-builder">Update: Is this just a <code>Builder</code>?</h2><p>A few folks on the internet have pointed out that this is very similar to the Builder pattern that you see prettyoften in Java/C# (and to a lesser extent in Go), and especially a multiphase <a href="https://www.svlada.com/step-builder-pattern/">Step Builder</a>.</p><p>I don’t think there’s a fundamental difference, but Builders that I’m familar with generally have a state-change/executestep (<code>Build()</code>) that produces an immutable object for use somewhere else, rather than doing any sort of effectfulexecution.  I think this pattern is both more general (you could certainly use it as a Builder) and has a differentpurpose.</p><div class="discussion">    <h3>Discussion</h3>    <ul><li><a href="https://lobste.rs/s/tzgizl/representing_state_as_interfaces_go">Lobsters</a></li><li><a href="https://news.ycombinator.com/item?id=39848164">Hacker News</a></li></ul></div>